{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE DeriveFunctor #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE TypeOperators #-}

module Expr where

import Test.QuickCheck

import Test.QuickCheck.Patterns.Rep
import Test.QuickCheck.Patterns.TH
import Test.QuickCheck.FreqArbitrary

data Expr a
  = ELit a
  | EAdd (Expr a) (Expr a)
  | EMul (Expr a) (Expr a)
  | EMbE (Maybe (Maybe (Expr a)))
  | ELst [Expr a]
  | EVar String
  deriving Show


foo :: Int -> Expr a -> Int -> a
foo 1 (EAdd (EVar "foo") (ELit _)) = undefined
foo 2 (EMul (ELit _) _)            = undefined
foo 3 (EMul (ELit _) _)            = undefined
foo _ _                            = undefined

bar :: Expr Int -> Bool
bar (EMul (EAdd _ _) _)         = undefined
bar (EAdd _ (EAdd _ (ELit 42))) = undefined
bar _                           = undefined

baz :: Expr a -> Bool
baz (EMul (EAdd _ (ELit _)) (EVar "baz")) = undefined
baz (EAdd _ (EAdd _ (ELit _)))            = undefined
baz (EMbE (Just _))                       = undefined
baz _                                     = undefined

deriveAll ''Expr [''Int] [('foo, 2), ('bar, 1), ('baz, 1)]

-- derivePF ''Expr
-- deriveFunPF 'foo [''Int]
-- deriveFunPF 'bar []
-- deriveFunPF 'baz [''Int]

instance FreqArbitrary a => FreqArbitrary1 (ExprF a) where
  liftFreqArbitrary f gen
    = smaller $ withFrequency f
    [ ('ELitF, ELitF <$> freqArbitrary f)
    , ('EAddF, EAddF <$> gen <*> gen)
    , ('EMulF, EMulF <$> gen <*> gen)
    , ('EMbEF, EMbEF <$> liftFreqArbitrary f (liftFreqArbitrary f gen))
    , ('ELstF, ELstF <$> liftFreqArbitrary f gen)
    , ('EVarF, EVarF <$> freqArbitrary f) ]

instance FreqArbitrary a => FreqArbitrary1 (Pat_foo a) where
  liftFreqArbitrary f gen
    = smaller $ withFrequency f
    [ ('Pat_foo_1
      , Pat_foo_1 <$> freqArbitrary f)

    , ('Pat_foo_1
      , Pat_foo_2 <$> freqArbitrary f <*> gen
        `suchThat` const True)
    , ('Pat_foo_3
      , Pat_foo_3 <$> freqArbitrary f <*> gen
        `suchThat` const True) ]

instance FreqArbitrary1 Pat_bar where
  liftFreqArbitrary f gen
    = smaller $ withFrequency f
    [ ('Pat_bar_1
      , Pat_bar_1 <$> gen <*> gen <*> gen)

    , ('Pat_bar_2
      , Pat_bar_2 <$> gen <*> gen
        `suchThat` const True) ]

instance FreqArbitrary a => FreqArbitrary1 (Pat_baz a) where
  liftFreqArbitrary f gen
    = smaller $ withFrequency f
    [ ('Pat_baz_1
      , Pat_baz_1 <$> gen <*> freqArbitrary f)

    , ('Pat_baz_2
      , Pat_baz_2 <$> gen <*> gen <*> freqArbitrary f
        `suchThat` const True)
    , ('Pat_baz_3
      , Pat_baz_3 <$> liftFreqArbitrary f gen
        `suchThat` const True) ]


freqs :: Name -> Size -> Maybe Freq
freqs cn 0
  -- | No recursive constructors
  | cn == 'EAdd = Just 0
  | cn == 'EMul = Just 0
  | cn == 'EMbE = Just 0
  | cn == 'ELst = Just 0
  -- | No patterns either
  | cn == 'Pat  = Just 0
freqs _ _ = Nothing


main :: IO ()
main = return ()

-- --------------------------------
-- -- Autogenerated code

-- data ExprF a r
--   = ELitF a
--   | EAddF r r
--   | EMulF r r
--   | EVarF String
--   deriving Functor

-- instance Algebra (ExprF a) (Expr a) where
--   alg (ELitF n)     = ELit n
--   alg (EAddF e1 e2) = EAdd e1 e2
--   alg (EMulF e1 e2) = EMul e1 e2
--   alg (EVarF v)     = EVar v

-- type instance PF (Expr a) = (ExprF a)

-- instance Rep (ExprF a) (Expr a)

-- data Pat_foo a t
--   = Pat_foo_1 a
--   | Pat_foo_2 a t
--   | Pat_foo_3 a t
--   deriving Functor

-- instance FAlgebra (Pat_foo a) (Expr a) where
--   alg (Pat_foo_1 n)   = EAdd (EVar "a") (ELit n)
--   alg (Pat_foo_2 a e) = EMul (ELit a) e
--   alg (Pat_foo_3 a e) = EMul (ELit a) e

-- data Pat_bar a t
--   = Pat_bar_1 t t t
--   | Pat_bar_2 t t a
--   deriving Functor

-- instance FAlgebra (Pat_bar a) (Expr a) where
--   alg (Pat_bar_1 e1 e2 e3) = EMul (EAdd e1 e2) e3
--   alg (Pat_bar_2 e1 e2 n)  = EAdd e1 (EAdd e2 (ELit n))

-- type instance Pattern "foo" = Pat_foo Int
-- type instance Pattern "bar" = Pat_bar
-- type instance Pattern "baz" = Pat_baz Int

-- ----------------------------------------
-- -- Code to tell our tool how to behave

type Expr_Int_foo_bar_baz = Interleave (Expr Int) '["foo", "bar", "baz"]

-- x :: Expr_Int_foo_bar_baz
-- x = rnd $ EAddF
--       (rnd $ ELitF 5)
--       (rnd $ ELitF 10)

-- y :: Expr_Int_foo_bar_baz
-- y = pat2 $ Pat_bar_1
--       (rnd $ ELitF 42)
--       (pat3 $ Pat_baz_3
--         (rnd $ EVarF "Hey"))
--       (pat1 $ Pat_foo_2
--          10
--          (rnd $ EVarF "Ho"))

y :: Expr_Int_foo_bar_baz
y = pat2 $ Pat_bar_1
      (rnd $ ELitF 42)
      (rnd $ ELitF 42)
      (rnd $ ELitF 42)


-- x' :: Expr Int
-- x' = eval x

-- y' :: Expr Int
-- y' = eval y
