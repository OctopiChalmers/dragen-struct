\documentclass[conference]{IEEEtran}

%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%












% Local Variables:
% TeX-master: "main.lhs.tex"
% TeX-command-default: "Make"
% End:

\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.

\usepackage{todonotes}
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{tikz}
\usepackage{mathdots}
\usepackage{yhmath}
\usepackage{cancel}
\usepackage{color}
\usepackage{siunitx}
\usepackage{array}
\usepackage{multirow}
\usepackage{amssymb}
\usepackage{gensymb}
\usepackage{tabularx}
\usepackage{booktabs}
\usepackage{caption}
\usepackage{xspace}
\usetikzlibrary{fadings}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Macros
\newcommand{\tocite}{\textbf{CITATION NEEDED}}
\newcommand{\quickcheck}{\emph{QuickCheck}\xspace}
\newcommand{\megadeth}{\emph{MegaDeTH}\xspace}
\newcommand{\dragen}{\textbf{DRAGEN}\xspace}



\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Title
\title{Synthesizing Random Generators via Higher-Order Representations}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Authors
\author{
  \IEEEauthorblockN{
    % 1\textsuperscript{st}
    Agust\'in Mista
  }
  \IEEEauthorblockA{
    % \textit{Department of Computer Science and Engineering} \\
    \textit{Chalmers University of Technology}\\
    Gothenburg, Sweden \\
    mista@chalmers.se
  }
\and
\IEEEauthorblockN{
  % 2\textsuperscript{nd}
  Alejandro Russo
  }
  \IEEEauthorblockA{
    % \textit{Department of Computer Science and Engineering} \\
    \textit{Chalmers University of Technology}\\
    Gothenburg, Sweden \\
    russo@chalmers.se
  }
}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Abstract

\begin{abstract}

  Pellentesque dapibus suscipit ligula. Donec posuere augue in quam. Etiam vel
  tortor sodales tellus ultricies commodo. Suspendisse potenti. Aenean in sem ac
  leo mollis blandit. Donec neque quam, dignissim in, mollis nec, sagittis eu,
  wisi. Phasellus lacus. Etiam laoreet quam sed arcu. Phasellus at dui in ligula
  mollis ultricies. Mauris mollis tincidunt felis. Aliquam feugiat tellus ut
  neque. Nulla facilisis, risus a rhoncus fermentum, tellus tellus lacinia
  purus, et dictum nunc justo sit amet elit.

\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Keywords
\begin{IEEEkeywords}
component, formatting, style, styling, insert
\end{IEEEkeywords}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Sections

\section{Introduction}

Pellentesque dapibus suscipit ligula. Donec posuere augue in quam. Etiam vel
tortor sodales tellus ultricies commodo. Suspendisse potenti. Aenean in sem ac
leo mollis blandit. Donec neque quam, dignissim in, mollis nec, sagittis eu,
wisi. Phasellus lacus. Etiam laoreet quam sed arcu. Phasellus at dui in ligula
mollis ultricies. Integer placerat tristique nisl. Praesent augue. Fusce
commodo. Vestibulum convallis, lorem a tempus semper, dui dui euismod elit,
vitae placerat urna tortor vitae lacus. Nullam libero mauris, consequat quis,
varius et, dictum id, arcu. Mauris mollis tincidunt felis. Aliquam feugiat
tellus ut neque. Nulla facilisis, risus a rhoncus fermentum, tellus tellus
lacinia purus, et dictum nunc justo sit amet elit.

Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Donec hendrerit tempor
tellus. Donec pretium posuere tellus. Proin quam nisl, tincidunt et, mattis
eget, convallis nec, purus. Cum sociis natoque penatibus et magnis dis
parturient montes, nascetur ridiculus mus. Nulla posuere. Donec vitae dolor.
Nullam tristique diam non turpis. Cras placerat accumsan nulla. Nullam rutrum.
Nam vestibulum accumsan nisl.

Aliquam erat volutpat. Nunc eleifend leo vitae magna. In id erat non orci
commodo lobortis. Proin neque massa, cursus ut, gravida ut, lobortis eget,
lacus. Sed diam. Praesent fermentum tempor tellus. Nullam tempus. Mauris ac
felis vel velit tristique imperdiet. Donec at pede. Etiam vel neque nec dui
dignissim bibendum. Vivamus id enim. Phasellus neque orci, porta a, aliquet
quis, semper a, massa. Phasellus purus. Pellentesque tristique imperdiet tortor.
Nam euismod tellus id erat\cite{grieco2017}.

The main contribuitions of this paper are:
%
\begin{itemize}
  %
\item We identify two patological scenarios for which standard type-driven
  automatic derivation tools fail to synthesize practical random generators, due
  to a lack of either type structure or domain knowleadge (Section
  \ref{sec:randomtesting}).
  %
\item We present a generation technique able to encode stronger properties of
  the target data by reifying the static information present on the program
  codebase (Section \ref{sec:hrep}).
  %
\item We apply and extend the theory of branching processes to analitically
  predict the average distribution of generated values.
  %
  Furthermore, we use the predictions to perform simulation-based optimization
  of the random generation parameters (Section \ref{sec:synthesis}).
  %
\item We provide an implementation of our ideas in the form of a Haskell library
  to perform automatic derivation of random generators capable to extract
  useful structure information from the user source code.
  %
\end{itemize}
\section{Type-Driven Random Generation} \label{sec:randomtesting}

In this section we briefly describe the common technique used for automatically
deriving random data generators in Haskell using a type-driven approach.
%
Then, we introduce its main drawbacks by considering two scenarios where this
technique gives poor results in practice.
%
We remark that, altough this work makes focus on Haskell data types, this
technique is general enough to be applied to most programming languages with
some level of support for composite types.


Haskell is a strongly typed programming language with a powerful type system.
%
It lets programmers encode a considerable amount of information about the
properties of their systems using data types that can be checked at compilation
time.
%
One of its key aspects is the support for Algebraic Data Types (ADTs).
%
Essentially, an ADTs is a composite type defined by combining other types.
%
In the most basic conception, types can be combined by \textbf{sums} (also known
as \emph{variant types} or \emph{tagged disjoint unions}) and \textbf{products}
(or tuples) of other data types.
%
To exemplify this, consider the following definition of the data type \ensuremath{\Conid{Exp}}
encoding integer expressions:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{20}{@{}>{\hspre}l<{\hspost}@{}}%
\column{25}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{Exp}{}\<[11]%
\>[11]{}\mathrel{=}{}\<[15]%
\>[15]{}\Conid{Val}\;{}\<[20]%
\>[20]{}\Conid{Int}{}\<[E]%
\\
\>[11]{}\;\;\vert\;{}\<[15]%
\>[15]{}\Conid{Add}\;{}\<[20]%
\>[20]{}\Conid{Exp}\;{}\<[25]%
\>[25]{}\Conid{Exp}{}\<[E]%
\\
\>[11]{}\;\;\vert\;{}\<[15]%
\>[15]{}\Conid{Mul}\;{}\<[20]%
\>[20]{}\Conid{Exp}\;{}\<[25]%
\>[25]{}\Conid{Exp}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

In the previous definition, we declare \ensuremath{\Conid{Exp}} as the sum of three possible
classes of values: \ensuremath{\Conid{Val}} represents literal values, whereas \ensuremath{\Conid{Add}} and \ensuremath{\Conid{Mul}}
represent the addition and multiplication of two integer expressions,
respectively.
%
In Haskell, \ensuremath{\Conid{Val}}, \ensuremath{\Conid{Add}} and \ensuremath{\Conid{Mul}} are called \emph{data constructors} and are
used to distiguish which variant of the data type we are reffering to.
%
Each data constructor is then defined as a product of zero or more types known
as \emph{fields}.
%
In particular, \ensuremath{\Conid{Val}} contains a field of type \ensuremath{\Conid{Int}}, while \ensuremath{\Conid{Add}} and \ensuremath{\Conid{Mul}}
contain two fields of type \ensuremath{\Conid{Exp}} representing the operands of each operation.
%
Note that \ensuremath{\Conid{Exp}} is used as a field of at least one of its data constructors
(case \ensuremath{\Conid{Add}} and \ensuremath{\Conid{Mul}}), making it a recursively defined ADT.
%
In general, we will say that a data constructor with no recursive fields is
\emph{terminal}, and \emph{non-terminal} or \emph{recursive} if it has at least
one field of such nature.
%
With this reprentation, the expression ``2 + (5 * 6)'' can be encoded simply by
using \ensuremath{\Conid{Exp}} data constructors as \ensuremath{(\Conid{Add}\;(\Conid{Val}\;\mathrm{2})\;(\Conid{Mul}\;(\Conid{Val}\;\mathrm{5})\;(\Conid{Val}\;\mathrm{6})))}.
%
Furthermore, an evaluation function from \ensuremath{\Conid{Exp}}s to integer values can be defined
very idiomatically:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{27}{@{}>{\hspre}c<{\hspost}@{}}%
\column{27E}{@{}l@{}}%
\column{30}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{eval}\mathbin{::}\Conid{Exp}\to \Conid{Int}{}\<[E]%
\\
\>[B]{}\Varid{eval}\;(\Conid{Val}\;\Varid{n}){}\<[17]%
\>[17]{}\mathrel{=}\Varid{n}{}\<[E]%
\\
\>[B]{}\Varid{eval}\;(\Conid{Add}\;\Varid{x}\;\Varid{y}){}\<[17]%
\>[17]{}\mathrel{=}\Varid{eval}\;\Varid{x}{}\<[27]%
\>[27]{}\mathbin{+}{}\<[27E]%
\>[30]{}\Varid{eval}\;\Varid{y}{}\<[E]%
\\
\>[B]{}\Varid{eval}\;(\Conid{Mul}\;\Varid{x}\;\Varid{y}){}\<[17]%
\>[17]{}\mathrel{=}\Varid{eval}\;\Varid{x}{}\<[27]%
\>[27]{}\mathbin{*}{}\<[27E]%
\>[30]{}\Varid{eval}\;\Varid{y}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

In the previous definition, \ensuremath{\Varid{eval}} is described using \emph{pattern matching}
over each possible kind of value.
%
For the input case of a literal values, we simply return the value contained in
the \ensuremath{\Conid{Val}} constructor.
%
On the other hand, if the input value matches either an \ensuremath{\Conid{Add}} or a \ensuremath{\Conid{Mul}} data
constructor, where \ensuremath{\Varid{x}} and \ensuremath{\Varid{y}} are \emph{pattern variables} that match any
subexpression, we recursively evaluate these subexpressions, combining them with
the apropiate operation on each case.

\subsection{\textbf{Type-Driven Generation of Random Values}}

In order to perform random testing of a Haskell codebase involving user defined
data types, most approaches require the user to provide a random data generator
for each one of them.
%
This tends to be a cumbersome and error prone task that closely follows the data
type structure.
%
For instance, consider the following definition of a \quickcheck random
generator for the type \ensuremath{\Conid{Exp}}:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}c<{\hspost}@{}}%
\column{7E}{@{}l@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{30}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{genExp}\mathbin{::}\Conid{Gen}\;\Conid{Exp}{}\<[E]%
\\
\>[B]{}\Varid{genExp}\mathrel{=}\Varid{sized}\;\Varid{gen}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{gen}\;\mathrm{0}\mathrel{=}\Conid{Val}\mathop{\langle \$ \rangle}\Varid{arbitrary}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{gen}\;\Varid{n}\mathrel{=}\Varid{oneof}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}[\mskip1.5mu {}\<[7E]%
\>[10]{}\Conid{Val}{}\<[15]%
\>[15]{}\mathop{\langle \$ \rangle}\Varid{arbitrary}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{},{}\<[7E]%
\>[10]{}\Conid{Add}{}\<[15]%
\>[15]{}\mathop{\langle \$ \rangle}\Varid{gen}\;(n{-}1){}\<[30]%
\>[30]{}\mathop{\langle \ast \rangle}\Varid{gen}\;(n{-}1){}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{},{}\<[7E]%
\>[10]{}\Conid{Mul}{}\<[15]%
\>[15]{}\mathop{\langle \$ \rangle}\Varid{gen}\;(n{-}1){}\<[30]%
\>[30]{}\mathop{\langle \ast \rangle}\Varid{gen}\;(n{-}1)\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
 %$

This random generator is defined using \quickcheck's combinator \ensuremath{\Varid{sized}\mathbin{::}(\Conid{Int}\to \Conid{Gen}\;\Varid{a})\to \Conid{Gen}\;\Varid{a}} to paremetrize the generation process up to an external
integer number known as the \emph{generation size}.
%
This parameter is used to limit the maximum amount of recursive call that this
random generator can perform.
%
When called with a positive generation size (case \ensuremath{\Varid{gen}\;\Varid{n}}), the generator is free
to randomly pick with uniform probability among any data constructor of \ensuremath{\Conid{Exp}}.
%
In the case it picks to generate a \ensuremath{\Conid{Val}} data constructor, it also generates a
random \ensuremath{\Conid{Int}} value using the standard overloaded generator \ensuremath{\Varid{arbitrary}}
(\quickcheck provides standard random generators for most base types like \ensuremath{\Conid{Int}},
\ensuremath{\Conid{Bool}}, etc.).
%
On the other hand, when it randomly picks to generate either an \ensuremath{\Conid{Add}} or a \ensuremath{\Conid{Mul}}
data constructor, it also generates independently two random subexpressions
corresponding to the data constructor fields by calling itself recursively (\ensuremath{\Varid{gen}\;(n{-}1)}), ensuring to decrease the generation size by a unit on each recursive
invocation.


This procedure keeps calling itself recursively until the generation size
reaches zero (case \ensuremath{\Varid{gen}\;\mathrm{0}}), where the generator is constrained to pick only
among terminal data constructors, being \ensuremath{\Conid{Val}} the only possible choice in our
particular case.
%
Strictly decreasing the the generation size by one on each recursive call
results in a useful property over the generated data: every generated value has
at most \ensuremath{\Varid{n}} levels, where \ensuremath{\Varid{n}} is the generation size set by the user.
%
This property enables us to model the generation process using the theory of
branching processes introduced by \tocite, and extended in this work as
described in Section \ref{sec:synthesis}.


Having discussed the previous random generator definition, it easy to understand
how to extend this generation procedure to any data type defined in an algebraic
fashion.
%
Fortunately, there exists different meta-programming tools to avoid the user
from having to mechanically write random generators over and over again for each
user-defined ADT.
%
The simplest tool for such purpose is \megadeth.
%
Given the name of the target data type, it synthesizes a random generator for it
that behaves pretty much like the previously defined one.
%
However, picking among different data constructors with uniform probability can
lead to a generation process biased to generate (in average) very small values,
regardless of the generation sized set by the user \tocite.

\dragen is meta-programming tool conceived to mitigate this problem.
%
Instead of setting a uniform generation probability of data constructors, this
tool considers the scenario where each one can be generated following a
different (although fixed over time) generation probability.
%
Then, this tool uses the theory of branching processes to analitically predict
the average distribution of data constructors generated on each random value.
%
This prediction mechanism is used to feedback a simulation-based optimization
process that adjusts the generation probability of each data constructor in
order to obtain a particular distribution of values that can be specified by the
user, offering a more flexible testing environment while still being mostly
automated.


Both \megadeth and \dragen synthesize random generators that are theoretically
capable to generate the whole space of values of the target data type, provided
that we set a generation size suficiently big.
%
However, the limitations arise quickly when we consider that the underlying
generation model is essentially the same: they pick a single data constructor
and recusively generate each required subexpression independently.
%
In practice, this procedure is too generic to generate complex data that is
useful enough to be used for random testing.


In this work we identify two sources of additional structure information which
are not considered by the aforementioned automatic derivation tools to obtain
random data generators:

\begin{enumerate}
\item The target code behaves differently over inputs matching very specific
  patterns.
\item The target code yields some of the responsability of preserving its
  invariants to the functions of its abstract interface.
\end{enumerate}

This information can be reified in compile time and used to synthesize richer
random generators automatically. We proceed to exemplify the previous points in
detail.

\subsection{\textbf{Presence of Complex Pattern Matchings}}

To exemplify the firts problematic scenarion that may arise, suppose we want to
use randomly generated \ensuremath{\Conid{Exp}}s to test a property comprising the following
function:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{foo}\mathbin{::}\Conid{Exp}\to \Conid{Exp}{}\<[E]%
\\
\>[B]{}\Varid{foo}\;(\Conid{Add}\;(\Conid{Add}\;\Varid{x}\;(\Conid{Val}\;\mathrm{50}))\;(\Conid{Add}\;(\Conid{Val}\;\mathrm{25})\;\Varid{y})){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}\Varid{error}\;\text{\ttfamily \char34 pattern~\#1\char34}{}\<[E]%
\\
\>[B]{}\Varid{foo}\;(\Conid{Mul}\;(\Conid{Val}\;\mathrm{50})\;(\Conid{Mul}\;(\Conid{Val}\;\Varid{x})\;\Varid{y})){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}\Varid{error}\;\text{\ttfamily \char34 pattern~\#2\char34}{}\<[E]%
\\
\>[B]{}\Varid{foo}\;\Varid{x}\mathrel{=}\Varid{x}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

This function behaves very much like an identity function, with the exception
that it fails for two very specific patterns of input values defined using
nested pattern matching.
%
This is, \ensuremath{\Varid{foo}} does not only matches against the root data constructor, but also
against the data constructors of its subexpressions and sub-subexpressions.


\quickcheck's default implementation for random \ensuremath{\Conid{Int}}s pick a number in the
interval $[-n, n]$ with uniform distribution.
%
Hence, in principle we need to recognize what is a suitable generation size,
which should be big enough for our generator be able to generate the numbers we
pattern match against to, otherwise we will not be able to generate any value to
match against \ensuremath{\Varid{foo}} clauses, leaving fragments of code completely untested.
%
Suppose then that we pick the a generation size $50$, i.e. the minimum size that
is big enough to produce an \ensuremath{\Conid{Int}} number equal to $50$.
%
Under this consideration, the probability of generating a value matching the
first clause of \ensuremath{\Varid{foo}} (and hence triggering the first error) results as follows:

\begin{align*}
  P(match(foo\#1))
  \!&&=\; &P(Add) \\
  \!&&*\; &P(Add) * 1 * (P(Val) * (1/100)) \\
  \!&&*\; &P(Add) * (P(Val) * (1/100)) * 1
\end{align*}

If we use \megadeth to obtain a random generator for \ensuremath{\Conid{Exp}}, we obtain a uniform
generation probability distribution over constructors, i.e., $P(\ensuremath{\Conid{Val}}) =
P(\ensuremath{\Conid{Add}}) = P(\ensuremath{\Conid{Mul}}) = 1/3$.
%
In this setting, $P(match(foo\#1))$ results $1/2430000$, meaning that, in
average, we will need to generate over than two million test cases in order to
be able to test the first clause of \ensuremath{\Varid{foo}} only once.
%
This situation can be somewhat improved if we decide to use \dragen to obtain a
random generator.
%
By optimizing the generation probabilities in order to benefit the generation of
\ensuremath{\Conid{Add}} constructor in a ratio of $20:1$ with respect to the rest of them, we
obtained a distribution of values where $P(match(foo\#1)) \sim 1/300000$.
%
Although this certainly improves the probability of generating a matching value,
this probability is not substantial enough to become practical.
%
Additionally, by favoring the generation probabilities towards the \ensuremath{\Conid{Add}}
constructor, we found that the probability of generating a value matching the
second clause of \ensuremath{\Varid{foo}} (which does not matches against it) also gets diminished
into an impractival value.


Despite the fact that the previous example might look artificial, branching
against specific patterns of the input data is a common task.
%
For instance, the balancing function of a Red-Black tree need to consider a
quite specific combination of color, left and right subtrees and sub-subtrees
in order to preserve the height invariant.
%
Moreover, Common Subexpression Elimination (CSE) is a compiler optimization that
needs to consider very specific sequences of instructions that may be regrouped
in a computationally more efficient way, to cite a few.



\subsection{\textbf{Data Invariants Encoded on Abstract Interfaces}}

A common choice when implementing a data structure is to transfer the
responsability of preserving its invariants to the functions that manipulates
its values.
%
Consider for instance the following possible implementation of a basic \ensuremath{\Conid{HTML}}
manipulation library:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{Html}\mathrel{=}\Conid{Html}\;\Conid{String}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{head}\mathbin{::}\Conid{Html}\to \Conid{Html}{}\<[E]%
\\
\>[B]{}\Varid{head}\;(\Conid{Html}\;\Varid{inner}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}\Conid{Html}\;(\text{\ttfamily \char34 <head>\char34}\plus \Varid{inner}\plus \text{\ttfamily \char34 </head>\char34}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{body}\mathbin{::}\Conid{Html}\to \Conid{Html}{}\<[E]%
\\
\>[B]{}\Varid{body}\;(\Conid{Html}\;\Varid{inner}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}\Conid{Html}\;(\text{\ttfamily \char34 <body>\char34}\plus \Varid{t}\plus \text{\ttfamily \char34 </body>\char34}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{br}\mathbin{::}\Conid{Html}{}\<[E]%
\\
\>[B]{}\Varid{br}\mathrel{=}\Conid{Html}\;\text{\ttfamily \char34 <br~/>\char34}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{concat}\mathbin{::}\Conid{Html}\to \Conid{Html}\to \Conid{Html}{}\<[E]%
\\
\>[B]{}\Varid{concat}\;(\Conid{Html}\;\Varid{x})\;(\Conid{Html}\;\Varid{y})\mathrel{=}\Conid{Html}\;(\Varid{x}\plus \Varid{y}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

In the previous definition, the \ensuremath{\Conid{Html}} data type is defined using a single data
constructor that contains the textual representation of the Html code it
represents in plain text.
%
Later, the combinator functions defined over \ensuremath{\Conid{HTML}} are the ones in charge of
transforming this plain text representation with the invariant that, given valid
\ensuremath{\Conid{Html}} parameters, they always return a valid \ensuremath{\Conid{Html}} value.
%
This is a very commmon programming pattern that can be found in a variety of
Haskell libraries \tocite{}.


If we use a standard type-driven approach to derive a random generator for
\ensuremath{\Conid{Html}}, the only ``structural'' information that we can use in the derivation
process is that \ensuremath{\Conid{Html}} values are composed of strings.
%
As a consequence, we essentially end up generating random strings, which rarely
represents a valid (or at least well structured) Html value.
%
Additionally, if our test suite contains properties constrained by certain
preconditions, this lack of domain knowleadge may lead in an impractically high
discard ratio of randomly generated test.
%
For instance, suposse we write a property to verify that \ensuremath{\Varid{head}} preserves the
invariant previously mentioned:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{prop\char95 head\char95 inv}\mathbin{::}\Conid{Html}\to \Conid{Bool}{}\<[E]%
\\
\>[B]{}\Varid{prop\char95 head\char95 inv}\;\Varid{x}\mathrel{=}\Varid{valid}\;\Varid{x}\Longrightarrow\Varid{valid}\;(\Varid{head}\;\Varid{x}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

In the previous definition we state that \ensuremath{\Varid{head}} always returns a valid \ensuremath{\Conid{Html}}
value (\ensuremath{\Varid{valid}\;(\Varid{head}\;\Varid{x})}), provided that we are given a valid \ensuremath{\Conid{Html}} as input
(\ensuremath{\Varid{valid}\;\Varid{x}}).
%
Then, while testing this property we rarely satisfy its precondition, in which
case \quickcheck discards the whole test, retrying with a diferent random input,
degradating this way the testing performance.


We believe that, if certain patterns of values are relevant enough to appear in
the codebase being tested, a practical random testing methodology should be able
to produce values satisfying such patterns in a substantial proportion.
%
The next section introduces a reprentation model that let us encode the
structure information presented here into our automatically derived random
generators in a modular and flexible way.


% Consider the following Haskell module |M| which defines combinators for the type
% |Exp|:

% \begin{code}
% module M where

% ten :: Exp
% ten = Val 10

% square :: Exp -> Exp
% square x = Mul x x

% minus :: Exp -> Exp -> Exp
% minus x y = Add x (Mul y (Val (-1)))
% \end{code}
\section{Extracting Structure} \label{sec:hrep}

In this work, we ...

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\text{HRep}_{Val}\;{}\<[16]%
\>[16]{}\Varid{a}\mathrel{=}\text{Mk}_{Val}\;\Conid{Int}{}\<[E]%
\\
\>[B]{}\mathbf{data}\;\text{HRep}_{Add}\;{}\<[16]%
\>[16]{}\Varid{a}\mathrel{=}\text{Mk}_{Add}\;\Varid{a}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\mathbf{data}\;\text{HRep}_{Mul}\;{}\<[16]%
\>[16]{}\Varid{a}\mathrel{=}\text{Mk}_{Mul}\;\Varid{a}\;\Varid{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

For this purpose, we employ Haskell's type classes mechanism \tocite{}.
%
We define an evaluation type class $(\Downarrow)$ which specifies how to perform
a single transformation \ensuremath{\Varid{step}} from the higher-order representation back into a
concrete value of the target:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{class}\;(\Varid{rep}\;\Downarrow\;\Varid{target})\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{step}\mathbin{::}\Varid{rep}\;\Varid{target}\to \Varid{target}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Then, we can define the following overloaded instances of the \ensuremath{\Varid{step}} operation
for the canonical representations of data constructors simply by mapping each
lifted constructor back into its corresponding one.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{instance}\;(\text{HRep}_{Val}\;\Downarrow\;\Conid{Exp})\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{step}\;(\text{Mk}_{Val}\;\Varid{n})\mathrel{=}\Conid{Val}\;\Varid{n}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{instance}\;(\text{HRep}_{Add}\;\Downarrow\;\Conid{Exp})\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{step}\;(\text{Mk}_{Add}\;\Varid{x}\;\Varid{y})\mathrel{=}\Conid{Add}\;\Varid{x}\;\Varid{y}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{instance}\;(\text{HRep}_{Mul}\;\Downarrow\;\Conid{Exp})\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{step}\;(\text{Mk}_{Mul}\;\Varid{x}\;\Varid{y})\mathrel{=}\Conid{Mul}\;\Varid{x}\;\Varid{y}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

With these individual representations, we can define a type combinator
$(\oplus)$ to compose two representations into a single one:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;(\Varid{f}\;\oplus\;\Varid{g})\;\Varid{a}\mathrel{=}\Conid{L}\;(\Varid{f}\;\Varid{a})\mid \Conid{R}\;(\Varid{g}\;\Varid{a}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Then, a composite representation can be transformed back into the concrete
target type by pattern matching on the data type variant and applying the \ensuremath{\Varid{step}}
tranformation to the inner representation:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{instance}\;(\Varid{f}\;\oplus\;\Varid{g}\;\Downarrow\;\Conid{Exp})\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{step}\;(\Conid{L}\;\Varid{f})\mathrel{=}\Varid{step}\;\Varid{f}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{step}\;(\Conid{R}\;\Varid{g})\mathrel{=}\Varid{step}\;\Varid{g}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Furthermore, we can define a type combinator ($\otimes$) to tag every
representation with an explicit generation frequency:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;(\Varid{f}\;\otimes\;\Varid{n})\;\Varid{a}\mathrel{=}\Conid{Freq}\;(\Varid{f}\;\Varid{a}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

This combinator is evaluated simply by piping the result from the inner
representation.
%
It does not change the evaluation semantics, as it is only considered at
generation time:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{instance}\;(\Varid{f}\;\otimes\;\Varid{n}\;\Downarrow\;\Conid{Exp})\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{step}\;(\Conid{Freq}\;\Varid{f})\mathrel{=}\Varid{step}\;\Varid{f}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks


\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{type}\;\text{HRep}_{Exp}{}\<[16]%
\>[16]{}\mathrel{=}\text{HRep}_{Val}\;\!\oplus\!\;\text{HRep}_{Add}\;\!\oplus\!\;\text{HRep}_{Mul}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks


\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;(\Varid{f}\;\otimes\;\Varid{n})\;\Varid{a}\mathrel{=}\Conid{TagFreq}\;(\Varid{f}\;\Varid{a}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{instance}\;(\Varid{f}\;\otimes\;\Varid{n}\;\Downarrow\;\Conid{Exp})\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{step}\;(\Conid{TagFreq}\;\Varid{f})\mathrel{=}\Varid{step}\;\Varid{f}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks


\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\text{HRep}_{foo\#1}\;{}\<[18]%
\>[18]{}\Varid{a}\mathrel{=}\text{Mk}_{foo\#1}\;\Varid{a}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\mathbf{data}\;\text{HRep}_{foo\#2}\;{}\<[18]%
\>[18]{}\Varid{a}\mathrel{=}\text{Mk}_{foo\#2}\;\Conid{Int}\;\Varid{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{instance}\;(\text{HRep}_{foo\#1}\;\Downarrow\;\Conid{Exp})\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{step}\;(\text{Mk}_{foo\#1}\;\Varid{x}\;\Varid{y}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathrel{=}\Conid{Add}\;(\Conid{Add}\;\Varid{x}\;(\Conid{Val}\;\mathrm{50}))\;(\Conid{Add}\;(\Conid{Val}\;\mathrm{25})\;\Varid{y}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{instance}\;(\text{HRep}_{foo\#2}\;\Downarrow\;\Conid{Exp})\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{step}\;(\text{Mk}_{foo\#2}\;\Varid{x}\;\Varid{y}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathrel{=}\Conid{Mul}\;(\Conid{Val}\;\mathrm{50})\;(\Conid{Mul}\;(\Conid{Val}\;\Varid{x})\;\Varid{y}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{21}{@{}>{\hspre}l<{\hspost}@{}}%
\column{37}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\text{HRep}_{ten}\;{}\<[21]%
\>[21]{}\Varid{a}\mathrel{=}\text{Mk}_{ten}{}\<[E]%
\\
\>[B]{}\mathbf{data}\;\text{HRep}_{square}\;{}\<[21]%
\>[21]{}\Varid{a}\mathrel{=}\text{Mk}_{square}\;{}\<[37]%
\>[37]{}\Varid{a}{}\<[E]%
\\
\>[B]{}\mathbf{data}\;\text{HRep}_{minus}\;{}\<[21]%
\>[21]{}\Varid{a}\mathrel{=}\text{Mk}_{minus}\;{}\<[37]%
\>[37]{}\Varid{a}\;\Varid{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{instance}\;(\text{HRep}_{ten}\;\Downarrow\;\Conid{Exp})\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{step}\;\text{Mk}_{ten}\mathrel{=}\Varid{ten}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{instance}\;(\text{HRep}_{square}\;\Downarrow\;\Conid{Exp})\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{step}\;(\text{Mk}_{square}\;\Varid{x})\mathrel{=}\Varid{square}\;\Varid{x}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{instance}\;(\text{HRep}_{minus}\;\Downarrow\;\Conid{Exp})\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{step}\;(\text{Mk}_{minus}\;\Varid{x}\;\Varid{y})\mathrel{=}\Varid{minus}\;\Varid{x}\;\Varid{y}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks


\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{24}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{type}\;\text{HRep}_{foo}{}\<[16]%
\>[16]{}\mathrel{=}{}\<[24]%
\>[24]{}\text{HRep}_{foo\#1}{}\<[E]%
\\
\>[16]{}\,\oplus\;{}\<[24]%
\>[24]{}\text{HRep}_{foo\#2}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{22}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{type}\;\text{HRep}_{M}{}\<[14]%
\>[14]{}\mathrel{=}{}\<[22]%
\>[22]{}\text{HRep}_{ten}{}\<[E]%
\\
\>[14]{}\,\oplus\;{}\<[22]%
\>[22]{}\text{HRep}_{square}{}\<[E]%
\\
\>[14]{}\,\oplus\;{}\<[22]%
\>[22]{}\text{HRep}_{minus}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{24}{@{}>{\hspre}l<{\hspost}@{}}%
\column{34}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{type}\;\text{Spec}_{Exp}{}\<[16]%
\>[16]{}\mathrel{=}{}\<[24]%
\>[24]{}\text{HRep}_{Exp}\;{}\<[34]%
\>[34]{}\otimes\;\mathrm{4}{}\<[E]%
\\
\>[16]{}\,\oplus\;{}\<[24]%
\>[24]{}\text{HRep}_{foo}\;{}\<[34]%
\>[34]{}\otimes\;\mathrm{2}{}\<[E]%
\\
\>[16]{}\,\oplus\;{}\<[24]%
\>[24]{}\text{HRep}_{M}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks


\begin{figure}[b]
  \centering
  \input{tikz/hrep.tex}
  \caption{The idea}
\end{figure}

Pellentesque dapibus suscipit ligula. Donec posuere augue in quam. Etiam vel
tortor sodales tellus ultricies commodo. Suspendisse potenti. Aenean in sem ac
leo mollis blandit. Donec neque quam, dignissim in, mollis nec, sagittis eu,
wisi. Phasellus lacus. Etiam laoreet quam sed arcu. Phasellus at dui in ligula
mollis ultricies. Integer placerat tristique nisl. Praesent augue. Fusce
commodo. Vestibulum convallis, lorem a tempus semper, dui dui euismod elit,
vitae placerat urna tortor vitae lacus. Nullam libero mauris, consequat quis,
varius et, dictum id, arcu. Mauris mollis tincidunt felis. Aliquam feugiat
tellus ut neque. Nulla facilisis, risus a rhoncus fermentum, tellus tellus
lacinia purus, et dictum nunc justo sit amet elit.

Nullam eu ante vel est convallis dignissim. Fusce suscipit, wisi nec facilisis
facilisis, est dui fermentum leo, quis tempor ligula erat quis odio. Nunc porta
vulputate tellus. Nunc rutrum turpis sed pede. Sed bibendum. Aliquam posuere.
Nunc aliquet, augue nec adipiscing interdum, lacus tellus malesuada massa, quis
varius mi purus non odio. Pellentesque condimentum, magna ut suscipit hendrerit,
ipsum augue ornare nulla, non luctus diam neque sit amet urna. Curabitur
vulputate vestibulum lorem. Fusce sagittis, libero non molestie mollis, magna
orci ultrices dolor, at vulputate neque nulla lacinia eros. Sed id ligula quis
est convallis tempor. Curabitur lacinia pulvinar nibh. Nam a sapien.

% \begin{code}
% data (Term f) a = TagTerm (f a)

% instance (Term f down Exp) where
%   step (TagTerm f) = step f
% \end{code}
\section{Random Generators Synthesis} \label{sec:synthesis}

Aliquam erat volutpat. Nunc eleifend leo vitae magna. In id erat non orci
commodo lobortis. Proin neque massa, cursus ut, gravida ut, lobortis eget,
lacus. Sed diam. Praesent fermentum tempor tellus. Nullam tempus. Mauris ac
felis vel velit tristique imperdiet. Donec at pede. Etiam vel neque nec dui
dignissim bibendum. Vivamus id enim. Phasellus neque orci, porta a, aliquet
quis, semper a, massa. Phasellus purus. Pellentesque tristique imperdiet tortor.
Nam euismod tellus id erat.

Nullam eu ante vel est convallis dignissim. Fusce suscipit, wisi nec facilisis
facilisis, est dui fermentum leo, quis tempor ligula erat quis odio. Nunc porta
vulputate tellus. Nunc rutrum turpis sed pede. Sed bibendum. Aliquam posuere.
Nunc aliquet, augue nec adipiscing interdum, lacus tellus malesuada massa, quis
varius mi purus non odio. Pellentesque condimentum, magna ut suscipit hendrerit,
ipsum augue ornare nulla, non luctus diam neque sit amet urna. Curabitur
vulputate vestibulum lorem. Fusce sagittis, libero non molestie mollis, magna
orci ultrices dolor, at vulputate neque nulla lacinia eros. Sed id ligula quis
est convallis tempor. Curabitur lacinia pulvinar nibh. Nam a sapien.

Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Donec hendrerit tempor
tellus. Donec pretium posuere tellus. Proin quam nisl, tincidunt et, mattis
eget, convallis nec, purus. Cum sociis natoque penatibus et magnis dis
parturient montes, nascetur ridiculus mus. Nulla posuere. Donec vitae dolor.
Nullam tristique diam non turpis. Cras placerat accumsan nulla. Nullam rutrum.
Nam vestibulum accumsan nisl.
% %include sections/casestudies.tex
\section{Related Work}

Aliquam erat volutpat. Nunc eleifend leo vitae magna. In id erat non orci
commodo lobortis. Proin neque massa, cursus ut, gravida ut, lobortis eget,
lacus. Sed diam. Praesent fermentum tempor tellus. Nullam tempus. Mauris ac
felis vel velit tristique imperdiet. Donec at pede. Etiam vel neque nec dui
dignissim bibendum. Vivamus id enim. Phasellus neque orci, porta a, aliquet
quis, semper a, massa. Phasellus purus. Pellentesque tristique imperdiet tortor.
Nam euismod tellus id erat.
\section{Final Remarks}

Nullam eu ante vel est convallis dignissim. Fusce suscipit, wisi nec facilisis
facilisis, est dui fermentum leo, quis tempor ligula erat quis odio. Nunc porta
vulputate tellus. Nunc rutrum turpis sed pede. Sed bibendum. Aliquam posuere.
Nunc aliquet, augue nec adipiscing interdum, lacus tellus malesuada massa, quis
varius mi purus non odio. Pellentesque condimentum, magna ut suscipit hendrerit,
ipsum augue ornare nulla, non luctus diam neque sit amet urna. Curabitur
vulputate vestibulum lorem. Fusce sagittis, libero non molestie mollis, magna
orci ultrices dolor, at vulputate neque nulla lacinia eros. Sed id ligula quis
est convallis tempor. Curabitur lacinia pulvinar nibh. Nam a sapien.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Bibliography
\bibliographystyle{IEEEtran}
\bibliography{references.bib}

\end{document}
