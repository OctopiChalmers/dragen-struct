{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE DeriveFunctor #-}

module Test.QuickCheck.Patterns.Rep where

import GHC.TypeLits
import Data.Kind

----------------------------------------

-- | Fix point of a data type. Just for illustration.
data Fix (f :: Type -> Type) = Fix { unFix :: (f (Fix f))}

-- | Fix point of a pair of data types.
-- If we have two pattern functors representing the same data type in different
-- ways, we can interleave them by selecting either FixL or FixR accordingly.
data Bifix (f :: Type -> Type) (g :: Type -> Type)
  = FixL (f (Bifix f g))
  | FixR (g (Bifix f g))

----------------------------------------

-- | We say that an interleaved pattern functor `f` can be translated to our
-- original type `a`, provided that we know how to translate any other
-- internally interleaved pattern functor.
class Rep f a where
  to :: (Rep g a, Rep g' a) => f (Bifix g g') -> a

----------------------------------------

-- | A type that represents values of type `t` that are built using either its
-- pattern functor (PF t) for completely random subexpressions, or a pattern
-- satisfying subexpression from a list of functions-patterns-encoding functors.
type Interleave (t :: Type) (fs :: [Symbol]) = Bifix (PF t) (Pats fs)

-- | If we know how to translate both pattern functors from an interleaved
-- value, we can translate it to our original data type `a` by "uninterleaving" the
-- interleaved structure.
uninterleave :: (Rep f a, Rep g a) => Bifix f g -> a
uninterleave (FixL f) = to f
uninterleave (FixR g) = to g

----------------------------------------

-- | Extensible sum types using "data types a la carte" approach.

-- | Empty type
data Empty a deriving Functor

-- | Generic sum type
data (f :+: g) a = InL (f a) | InR (g a) deriving Functor

instance (Rep f a, Rep g a) => Rep (f :+: g) a where
  to (InL f) = to f
  to (InR g) = to g

----------------------------------------

-- | Some type families to reduce the noise
-- | Associate each type to its correspondent pattern functor.
type family PF   (t  :: Type)     :: Type -> Type

-- | Associate each pattern type to its corresponding function.
type family Pat  (f  :: Symbol)   :: Type -> Type
type family Pats (fs :: [Symbol]) :: Type -> Type

type instance Pats '[]       = Empty
type instance Pats (f ': fs) = Pat f :+: Pats fs

----------------------------------------

data Fix' (f :: Type -> Type) = Fix' { unFix' :: (f (Fix' f))}

cata :: Functor f => (f a -> a) -> Fix' f -> a
cata f = f . fmap (cata f) . unFix'

class Algebra f a where
  alg :: f a -> a

instance Algebra Empty a where
  alg = error "impossible happened"

instance (Algebra f a, Algebra g a) => Algebra (f :+: g) a where
  alg (InL f) = alg f
  alg (InR g) = alg g

class (Functor f, Algebra f a) => Rep' f a where
  to' :: Rep' g a => f (Fix' g) -> a
  to' = alg . fmap foldRep'

  foldRep' :: Rep' f a => Fix' f -> a
  foldRep' = cata alg

instance Rep' Empty a
instance (Rep' f a, Rep' g a) => Rep' (f :+: g) a

type Bifix' f g = Fix (f :+: g)

type Interleave' (t :: Type) (fs :: [Symbol]) = Bifix' (PF t) (Pats fs)

data (f :?: g) a
  = Rnd (f a)
  | Pat (g a)
  deriving Functor
