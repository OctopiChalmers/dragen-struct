\section{Type-Level Generation Specifications}
\label{sec:typelevel}

% --------------------------------------
% Intro
%
This section introduces refinements to our basic language for describing random
generators, making it more flexible and robust in order to fit real-world usage
scenarios.


% --------------------------------------
% Naming conventions
%
% To begin with, let us consider the name conventions we used when defining our
% representation data types along this paper.
%
% Since our aim is to automate this process as much as possible using Haskell's
% meta-programming capabilities,
%
The first problem we face is that of naming conventions.
%
In practice, the actual names used when deriving construction representations
need to be generated in such a way that they are compliant with Haskell's
syntax, and also that they are \emph{unique within our namespace}.
%
This means that, type names like |Fun_cat| or |Pat_simplify_1| are, technically,
not valid Haskell data type names, thus they will have to be synthesized as
something like |Fun_lt_plus_gt_543| and |Pat_simplify_1_325|, where the last
sequence of numbers is inserted by Template Haskell to ensure uniqueness.


This naming convention results hard to use, specially if we consider that we do
not know the actual type names until they are synthesized in compile-time, due
to their unique suffixes.
%
Fortunately, it is easy to solve this problem using some type-level machinery.
%
Instead of imposing a naming convention in our derivation tool, we define a set
of open type families to hide each kind of construction behind meaningful names:

\begin{code}
type family Con (c :: Symbol)             :: * -> *
type family Fun (f :: Symbol)             :: * -> *
type family Pat (p :: Symbol) (n :: Nat)  :: * -> *
\end{code}
%
where |Symbol| is the kind of type-level strings in Haskell.
%
Then, our derivation process will synthesize each representation using unique
names, along with a type instance of the corresponding type family.
%
For instance, along with the representations of |Con_Text|, |Fun_cat| and
|Pat_simplify_1|, we will automatically derive the following type instances:

\begin{code}
type instance Con "Text"        = Con_Text_123
type instance Fun "<+>"         = Fun_lt_plus_gt_543
type instance Pat "simplify" 1  = Pat_simplify_1_325
\end{code}
%
As a result, the end user can simply refer to each particular construction by
using these synonyms, e.g., with representation types like |Con "Text" oplus'
Fun "<+>"|.
%
The additional |Nat| type parameter on |Pat| simply identifies each pattern
number uniquely.


Moreover, we can define a \emph{terminal} version of each kind of construction
to avoid having to explicitly wrap constructions using |Term| combinators:

\begin{code}
type Con' a    = Term  (Con a)
type Pat' a n  = Term  (Pat a n)
type Fun' a    = Term  (Fun a)
\end{code}
%
This way, any construction with the supra-index |T| will considered to be
terminal.


With these type-level manipulations, we are now able to write generation
specifications in a clear and concise way.
%
For instance, we can specify a complex random generator for |Html| values as
follows:

\begin{code}
type Html_Spec
  =      Con'  "Text"
  oplus  Con   "Join"         otimes 2
  oplus  Fun'  "br"           otimes 4
  oplus  Fun   "<+>"          otimes 9
  oplus  Pat   "simplify"  1  otimes 3
  oplus  Pat   "simplify"  2  otimes 5
\end{code}

And simply obtain a concrete generator by refering to |Html_Spec| when using
|genRep|:

\begin{code}
genHtml :: BGen Html
genHtml = genRep at Html_Spec
\end{code}


% --------------------------------------
% Parametric target data types
%
\subsection{Parametric Target Data Types }

So far we have seen how to specify random generators for our simple
self-contained |Html| data type.
%
In practice, however, we are often required to write random generators for
parametric target data types as well.
%
Consider, for example, the following |Tree| data type definition encoding binary
trees with generic information of type |a| in the leaves:

\begin{code}
data Tree a = Leaf a | Node (Tree a) (Tree a)
\end{code}

In order to represent its data constructors, we can follow the same recipe
presented in Section \ref{sec:representation}, but also parametrizing our
representations over the type variable |a| as well:

\begin{code}
data Con_Leaf a r = Mk_Leaf a
data Con_Node a r = Mk_Node r r
\end{code}

Then, the rest of the machinery can be derived in the same way as before,
carrying this type parameter and including the appropriate |Arbitrary|
constraints all along the way:

\begin{code}
instance Algebra (Con_Leaf a) (Tree a) where dots
instance Algebra (Con_Node a) (Tree a) where dots

instance Arbitrary a => BArbitrary1 (Con_Leaf a) where dots
instance Arbitrary a => BArbitrary1 (Con_Node a) where dots
\end{code}

% The biggest different appears when deriving the required type instances for the
% |Con|, |Fun| and |Pat| synonyms.
%
However, instead of carrying this type parameter in our generation
specifications, we can avoid it by hiding it using an existential type:

\begin{code}
data Some (f :: * -> * -> *) (r :: *) = forall (a :: *) dot SomeC (f a r)
\end{code}
%
The type constructor |Some| is a wrapper for a 2-parametric type that hides the
first type variable using an explicit existential quantifier.
%
Note thus that the type parameter |a| does not appears at the left hand side of
|Some| on its defition.
%
Then, when deriving any |Con|, |Fun| or |Pat| type instance, we will wrap each
construction representation using a |Some|:

\begin{code}
type instance Con "Leaf" = Some Con_Leaf
type instance Con "Node" = Some Con_Node
\end{code}

And we can therefore write generation specifications for our |Tree| data type
without having to refer to its type parameter anywhere.
%
For instance:

\begin{code}
type Tree_Spec  =      Con'  "Leaf"  otimes 2
                oplus  Con   "Node"  otimes 3
\end{code}
%
Instead, we defer handling this type parameter until we actually use it to
define a concrete generator.
%
For instance, we can write a concrete generator of |Tree Int| as follows:

\begin{code}
genIntTree :: BGen (Tree Int)
genIntTree = genRep at (Tree_Spec apply' Int)
\end{code}
%
Where |apply| is a closed type family that traverses our generation
specification, applying the |Int| type to every occurrence of |Some|:

\begin{code}
type family (f :: * -> *) apply' (a :: *) :: * -> * space where
  (Some f)         apply'  a  = f a
  (f oplus''  g)   apply'  a  = (f apply' a) oplus'' (g apply' a)
  (f otimes'' n)   apply'  a  = (f apply' a) otimes'' n
  (Term f)         apply'  a  = Term (t apply' a)
  f                apply'  a  = f
\end{code}
%
As a result, in |genIntTree|, the |apply| operator will reduce the type
|(Tree_Spec apply'' Int)| to the following concrete type:

\begin{code}
(Term (Con_Leaf Int) otimes' 2) oplus' ((Con_Node Int) otimes' 3)
\end{code}

It is worth mentioning that this approach for handling parametric types can be
extended to multi-parametric data types with minor effort.


Along with our automated constructions derivation mechanism, the machinery
introduced in this section allows us to specify random generators using a
concise and flexible type-level combinators language.
%
The next section evaluates our approach in terms of performance using a set of
case studies extracted from real-world Haskell implementations.
