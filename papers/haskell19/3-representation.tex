\section{Unified Representation of Constructions}
\label{sec:representation}

% --------------------------------------
% The basic idea
%
This section introduces a unified representation for the different constructions
we might want to consider when generating random values.
%
The key idea of this work is to lift each different source of structural
information into the type level.
%
In this light, the ``shape'' of our random data is determined entirely by
the type we use to represent it during the generation process.
%
For this, we will define a set of different simple ``open'' data types,
each one in charge of representing a single construction of our target data
type.
%
These types can be later
\begin{inparaenum}[(i)]
\item combined in several ways depending on the desired shape of our test data,
\item randomly generated (see Section \ref{sec:generators}), and finally,
\item transformed back into the corresponding values of the target data type
  automatically.
\end{inparaenum}
%
This lifted representation of constructions can be automatically derived from
our source code in compile-time, relieving programmers of the burden of manually
implementing this required machinery.


% --------------------------------------
% Representing data constructors
%
When generating values of algebraic data types, the simplest piece of meaningful
information we ought to consider is the one given by each one of its data
constructors.
%
\footnote{We explicitly avoid considering $\bot$ when generating random values.}
%
In this light, each individual data constructor of the target data type can be
represented simply by a new data type with a single constructor.
%
Recalling our |Html| example, its data constructors can be represented as
follows:

\begin{code}
data Con_Text   r = Con_Text  String
data Con_Sing   r = Con_Sing  String
data Con_Tag    r = Con_Tag   String r
data Con_Join   r = Con_Join  r r
\end{code}

Where each representation has the same fields as its corresponding constructor,
except for the recursive ones which are abstracted away using a type parameter
|r|.
%
This parametricity lets us leave the type of each recursive sub-term unspecified
until we have decided the overall shape of our random data.
%
Then, for instance, the value |Con_Tag "div" x :: Con_Tag y| represents the
|Html| value |Tag "div" x|, for some sub-term |x :: y| that can be transformed
back to |Html| as well.
%
It is easy to note how each one of these simple representations encode the
minimal amount of information they need, leaving everything else unspecified.

An important property of these parametric representations is that, in most
cases, they form a functor over its type parameter, and thus we can use
Haskell's |deriving| mechanism to obtain a suitable |Functor| instances for
free:

\begin{code}
deriving instance Functor Con_Text
deriving instance Functor Con_Sing
deriving instance Functor Con_Tag
deriving instance Functor Con_Join
\end{code}


% --------------------------------------
% F-Algebras
%
The next building block of our approach consists of providing a mapping from
each constructor representation to its actual target value, provided that each
recursive sub-term has already been translated to its corresponding target
value.
%
For this purpose, we will define a type class |Algebra| as follows:

\begin{code}
class Functor f => Algebra f a | f -> a where
  alg :: f a -> a
\end{code}

Where |f| is the functor type used to represent a construction of the target
type |a|.
%
Note the functional dependency |f -> a|, ensuring that a given representation
|f| can be translated to a unique target type |a|.
%
This mapping is usually referred categorically as an F-Algebra.
%




\begin{code}
instance Algebra Con_Text Html where
  alg (Con_Text x) = Text x

instance Algebra Con_Sing Html where
  alg (Con_Sing x) = Sing x

instance Algebra Con_Tag Html where
  alg (Con_Tag t x) = Tag t x

instance Algebra Con_Join Html where
  alg (Con_Join x y) = Join x y
\end{code}


\begin{code}
data ((f :: * -> *) oplus (g :: * -> *)) a = InL (f a) | InR (g a)
\end{code}


\begin{code}
instance (Algebra f a, Algebra g a)
  => Algebra (f oplus g) a where
  alg (InL f) = alg f
  alg (InR g) = alg g
\end{code}


\begin{code}
  data Fix (f :: * -> *) = Fix { unFix :: (f (Fix f)) }
\end{code}

\begin{code}
eval :: Algebra f a => Fix f -> a
eval = alg . fmap eval . unFix
\end{code}


\begin{code}
data Fun_br     r = Fun_br
data Fun_bold   r = Fun_bold r
data Fun_cat    r = Fun_cat r r
data Fun_list   r = Fun_list [r]
\end{code}

\begin{code}
data Pat_simplify_1 r = Pat_simplify_1 String String
data Pat_simplify_2 r = Pat_simplify_2 String r r
\end{code}

\begin{code}
instance Algebra Fun_br Html where
  alg Fun_br = br

instance Algebra Fun_bold Html where
  alg (Fun_bold x) = bold x

instance Algebra Fun_cat Html where
  alg (Fun_cat x y) = x <+> y

instance Algebra Fun_list Html where
  alg (Fun_list xs) = list xs
\end{code}

\begin{code}
instance Algebra Pat_simplify_1 Html where
  alg (Pat_simplify_1 t1 t2) = Join (Text t1) (Text t2)

instance Algebra Pat_simplify_2 Html where
  alg (Pat_simplify_1 t x y) = Join (Join (Text t) x) y
\end{code}


Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Donec hendrerit tempor
tellus. Donec pretium posuere tellus. Proin quam nisl, tincidunt et, mattis
eget, convallis nec, purus. Cum sociis natoque penatibus et magnis dis
parturient montes, nascetur ridiculus mus. Nulla posuere. Donec vitae dolor.
Nullam tristique diam non turpis. Cras placerat accumsan nulla. Nullam rutrum.
Nam vestibulum accumsan nisl\cite{godefroid2005dart}.
