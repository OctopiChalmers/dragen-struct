\section{Unified Representation of Constructions}
\label{sec:representation}

% --------------------------------------
% The basic idea
%
This section introduces a unified representation for the different constructions
we might want to consider when generating random values.
%
The key idea of this work is to lift each different source of structural
information at the type level.
%
In this light, the ``shape'' of our random data is determined entirely by the
type we use to represent it during the generation process.


For this, we will define a set of different simple ``open'' types, each one in
charge of representing a single construction of our \emph{target} data type,
i.e., the actual data type we want to randomly generate.
%
These types can be later
%
\begin{inparaenum}[(i)]
\item combined in several ways depending on the desired shape of our test data
  (applying the familiar \`a la Carte technique);
\item randomly generated (see Section \ref{sec:generators}); and finally,
\item transformed back to the corresponding values of the target data type
  automatically.
\end{inparaenum}
%
This lifted representation of constructions can be automatically derived from
our source code in compile-time, relieving programmers of the burden of manually
implementing the required machinery.


% --------------------------------------
% Representing data constructors
%
\subsection{Representing Data Constructors}

When generating values of algebraic data types, the simplest piece of meaningful
information we ought to consider is the one given by each one of its data
constructors.
%
\footnote{We explicitly avoid considering $\bot$ when generating random values.}
%
In this light, each data constructor of the target data type can be represented
using a single-constructor data type.
%
Recalling our |Html| example, its data constructors can be represented as:
%
\looseness=-1 % I hate having to use this!

\begin{code}
data Con_Text   r = Mk_Text  String
data Con_Sing   r = Mk_Sing  String
data Con_Tag    r = Mk_Tag   String r
data Con_Join   r = Mk_Join  r r
\end{code}
%
Note that each representation has the same fields as its corresponding
constructor, except for the recursive ones which are abstracted away using a
type parameter |r|.
%
This parametricity lets us leave the type of each recursive sub-term unspecified
until we have decided the overall shape of our random data.
%
Then, for instance, the value |Mk_Tag "div" x :: Con_Tag r| represents the
|Html| value |Tag "div" x|, for some sub-term |x :: r| that can be transformed
back to |Html| as well.
%
It is easy to note how each of these simple representations encode the minimal
amount of information they need, leaving everything else unspecified.

An important property of these parametric representations is that, in most
cases, they form a functor over its type parameter, and thus we can use
Haskell's |deriving| mechanism to obtain suitable |Functor| instances for free:

\begin{code}
deriving instance Functor Con_Text
deriving instance Functor Con_Sing
deriving instance Functor Con_Tag
deriving instance Functor Con_Join
\end{code}


% --------------------------------------
% F-Algebras
%
Then, the next building block of our approach consists of providing a mapping
from each constructor representation to its actual target value, provided that
each recursive sub-term has already been translated to its corresponding target
value.
%
Categorically, this is often referred as an F-Algebra over the functor we use to
encode our different constructions.
%
We will represent this mapping defining a type class |Algebra| with a single
method |alg| as follows:

\begin{code}
class Functor f => Algebra f a | f -> a where
  alg :: f a -> a
\end{code}
%
where |f| is the functor type used to represent a construction of the target
type |a|.
%
Note the functional dependency |f -> a|, helping the type checker to solve
uniquely the free type variable |a| at the right hand side of the |=>|, based on
the type |f| used to represent it.
%
% In practical terms, it ensures that each representation type |f| will be
% translated to a unique target type |a|.
%
Then, we need to instantiate this type class for each data constructor
representation we are considering, providing an appropriate implementation for
the overloaded |alg| function.
%
To do so, we can simply transform each constructor representation by picking its
corresponding data constructor, and piping its fields unchanged:

\begin{code}
instance Algebra Con_Text Html where
  alg (Mk_Text x) = Text x

instance Algebra Con_Sing Html where
  alg (Mk_Sing x) = Sing x

instance Algebra Con_Tag Html where
  alg (Mk_Tag t x) = Tag t x

instance Algebra Con_Join Html where
  alg (Mk_Join x y) = Join x y
\end{code}


Note how every definition regarding each different constructor so far was
obtained rather mechanically.
%
This let us automate the process quite a bit using Haskell's meta-programming
capabilities.


% --------------------------------------
% Generic sums
%
\subsection{Composing Representations}

So far we have seen how to represent each data constructor of our |Html| data
type independently.
%
In order to represent interesting values, we need to be able to combine these
single representations into (possibly complex) composite ones.
%
For this purpose, we will define a generic functor type |oplus| to encode the
choice between two given representation types as follows:

\begin{code}
data ((f :: * -> *) oplus'' (g :: * -> *)) r = InL (f r) | InR (g r)

instance (Functor f, Functor g) => Functor (f oplus'' g)
  where  fmap h (InL fa) = InL (fmap h fa)
         fmap h (InR ga) = InR (fmap h ga)

\end{code}
%
This infix type-level operator let us combine two representations |f| and |g|
into a composite one |f oplus'' g|, representing either a value from |f| (via
the |InL| constructor) or a value from |g| (via the |InR| constructor).
%
This operator works pretty much in the same way as Haskell's |Either| data type,
except that, instead of combining two base types, it works combining two
\emph{parametric type constructors}, hence the kind signature |* -> *| in both
|f| and |g|.
%
For instance, we can use the type |Con_Text oplus'' Con_Tag| to encode values
representing either plain text HTMLs or paired tags.
%
Such values can be constructed easily using the injections |InL| and |InR| on
each each case, respectively.


The next step consists of providing an |Algebra| type instance for composite
representations, provided that each side of the sum can be translated back to
the same target type:

\begin{code}
instance (Algebra f a, Algebra g a) => Algebra (f oplus'' g) a
  where  alg (InL fa) = alg fa
         alg (InR ga) = alg ga
\end{code}
%
where we simply use the appropriate |Algebra| instance for the inner
representation, based on which injection was used to construct the composite
value.
%
It is worth remarking that multiple compositions are handled transparently,
i.e., for every set of types |f1|, |f2|, ..., |fk| representing a target type
|t| and having suitable |Algebra| type instances, then the composition |f1
oplus'' f2 oplus'' dots oplus'' fk| can be mapped back to |t| using this same
mechanism.
%
Additionally, the order in which we associate each operand of |oplus| results
semantically irrelevant, thus we can omit parentheses when describing composite
representations.
%
However, in practice, the way in which we associate our constructions affects
the generation speed dramatically.
%
This phenomena is addressed in detail in Section \ref{sec:casestudies}.
%
For simplicity here, we will assume |oplus| as having right associativity, i.e.,
|f oplus'' g oplus'' h == f oplus'' (g oplus'' h)|.


% --------------------------------------
% Fixed points
%
\subsection{Tying the Knot}

Even though we have already seen how to encode single and composite
representations for our target data types, there is as piece of machinery still
missing: our representations are not recursive, but parametric on its recursive
fields.
%
We can think of them as a encoding a `'single layer'' of our target data.
%
In order to represent recursive values, we need to close them ``tying the knot''
recursively, i.e., once we have fixed a suitable representation for our target
data, we want each one of its recursive fields to be instantiated with itself.
%
This can be easily achieved by using a type-level fixed point operator:

\begin{code}
newtype Fix (f :: * -> *) = FixC { unFix :: f (Fix f) }
\end{code}
%
Given a parametric type |f| of kind |* -> *| representing some target data type,
the type |Fix f| instantiates each recursive field of |f| with |Fix f|, thus
closing the definition of |f| into itself---note thus that the kind of |Fix f|
results |*|.
%
In addition, note that we defined |Fix| as a |newtype|.
%
This way, the compiler will avoid producing a runtime representation for it,
helping to reduce some of the unnecessary overhead.
%
This is possible since we only use it as a wrapper to obtain a self-recursive
type from a parametric one.


In general, if |f| is a representation for a given target type, we will refer to
|Fix f| as a \emph{final representation}, since it cannot be further combined or
extended---the |oplus| operator has to be applied \emph{within} the |Fix| type
constructor.


The effect of a fixed point combinator is much easier to interpret considering
an example.
%
Let us imagine we want to represent our |Html| data type using all of its data
constructors.
%
For this purpose we use the following type to represent it:

\begin{code}
type Html' = Con_Text oplus'' Con_Sing oplus'' Con_Tag oplus'' Con_Join
\end{code}
%
Then, for instance, the value:

\begin{code}
  x :: Html
  x = Join (Text "hello") (Sing "hr")
\end{code}
%
can be represented with |Html'| as:

\begin{code}
  x' ::  Fix Html'
  x' =   FixC  (InR  (InR (InR (Mk_Join
               (FixC (InL (Mk_Text "hello")))
               (FixC (InR (InL (Mk_Sing "hr"))))))))
\end{code}
%
where the sequences of |InL| and |InR| data constructors \emph{inject} each
value from an individual representation into the appropriate position of our
composite representation |Html'|.


Finally, given the value |x' :: Fix Html'|, we can evaluate it back to its
corresponding |Html| value as follows:

\begin{code}
eval :: Algebra f a => Fix f -> a
eval = alg . fmap eval . unFix
\end{code}
%
This function exploits the |Functor| structure of our representations,
unwrapping the fixed points and mapping their algebras to the result of
evaluating recursively each recursive sub-term.
%
This recursion schema using functors and F-Algebras to fold data generically has
been well studied and is known a \emph{catamorphism} \cite{Meijer91}.

In our particular example, this function satisfies the equation |eval x' == x|.
%
More specifically, one can prove that the types |Html| and |Fix Html'| are in
fact isomorphic, with |eval| as the witness of one side of this
isomorphism---though this is not usually the case for every representation we
choose for our data.


% --------------------------------------
% Representing other constructions
%
\subsection{Representing Additional Constructions}

The representation mechanism we have developed so far let us determine the shape
of our target data based on the type we use to represent its constructors.
%
However, it is hardly useful for performing random testing, as it only adds
unnecessary complexity to the random generation process.
%
It is not until we start considering more complex constructions that this
approach becomes particularly appealing.

%
% Abstract interfaces
%
\subsubsection{Abstract Interfaces}

Firstly, let us consider the case of generating values obtained by abstract
interface functions.
%
If we recall our |Html| example, we note that it is possible to use the
functions on its abstract interface to obtain |Html| values based on different
input arguments:

\begin{code}
br     ::                      Html
bold   ::  Html    ->          Html
list   ::  [Html]  ->          Html
(<+>)  ::  Html    -> Html ->  Html
\end{code}
%
Fortunately, it is easy to extend our approach to incorporate the interesting
structure arising from these functions into our representations.
%
As before, we first need to define a set of simple data types to encode each
construction:

\begin{code}
data Fun_br     r = Mk_br
data Fun_bold   r = Mk_bold r
data Fun_list   r = Mk_list [r]
data Fun_cat    r = Mk_cat  r r
\end{code}
%
Each one of these data types represents a value resulting from evaluating its
corresponding function, using as input arguments the values encoded on its
fields.
%
Once again, we replace each recursive field (representing a recursive input
argument) with a type parameter |r| in order to leave the type of the recursive
sub-terms unspecified until we have decided the final shape of our data.


Note that, by representing values obtained from function application this way,
we are not performing any actual computation---we simply store the functions'
input arguments.
%
Instead, the actual functions are evaluated when transforming our
representations back to their target type, by the means of an |Algebra|:

\begin{code}
instance Algebra Fun_br Html where
  alg Mk_br = br

instance Algebra Fun_bold Html where
  alg (Mk_bold x) = bold x

instance Algebra Fun_list Html where
  alg (Mk_list xs) = list xs

instance Algebra Fun_cat Html where
  alg (Mk_cat x y) = x <+> y
\end{code}
%
There, we simply return the result of evaluating each function, using its
representation fields as an input arguments.


It is important to remark that this approach inherits any possible downside from
the functions we use to represent our target data.
%
In particular, using non-terminating functions to represent our data might
produce a non-terminating behavior when calling to the |eval| function.


%
% Functions pattern matchings
%
\subsubsection{Functions' pattern matchings}

The second source of structural information that we consider in this work is the
one present in functions' pattern matchings.
%
If we recall to our |simplify| from Section \ref{sec:sources}, we can observe it
has two complex, non-trivial patterns that we might want to satisfy when
generating random values:

\begin{code}
simplify (Join (Text t1) (Text t2))   = dots
simplify (Join (Join (Text t1) x) y)  = dots
\end{code}
%
We can extend our approach in order to represent these patterns as well.
%
We start defining single data types for each one of them, this time encoding in
the fields of each single data constructor the free pattern variables (or
wildcards) appearing in its corresponding pattern, from left to right:

\begin{code}
data Pat_simplify_1 r = Mk_simplify_1 String String
data Pat_simplify_2 r = Mk_simplify_2 String r r
\end{code}
%
where the number after the |#| distinguishes the different patterns from the
function |simplify| by the index of the clause they belong to.
%
Once again, we abstracted away every recursive field (this time corresponding to
a recursive pattern variable or wildcard) using a type variable |r| until we
have decided the final shape of our target data.


Then, each |Algebra| instance will expand pattern representations into the
corresponding target values resembling such patterns, where each pattern
variable gets instantiated using the values stored in its representation field:

\begin{code}
instance Algebra Pat_simplify_1 Html where
  alg (Mk_simplify_1 t1 t2) = Join (Text t1) (Text t2)

instance Algebra Pat_simplify_2 Html where
  alg (Mk_simplify_1 t x y) = Join (Join (Text t) x) y
\end{code}


%
% Closing
%
\subsubsection{Ensambling Altogether}

Using the constructions presented so far, we are now able to represent values of
our target data using a higher level of abstraction.
%
Instead of constructing values solely by combining different data constructors,
this mechanism lets us also consider complex constructions like abstract
interface functions and functions' patterns, treating them uniformingly and in a
fine grained fashion.


As we have introduced in the Section \ref{sec:sources}, having an extensible,
fine-grained framework for generating random data might be of great advantage,
as we would like to generate random test cases following different strategies
when testing different properties or sub-systems.
%
For instance, generating values satisfying the pattern matchings of the function
|simplify| could be relevant only when testing properties involving such
function.
%
For this purpose, we could represent |Html| values as follows:
%
\begin{code}
type Html_simplify  =      Con_Text oplus'' Con_Sing oplus'' Con_Tag oplus'' Con_Join
                    oplus  Pat_simplify_1 oplus'' Pat_simplify_2
\end{code}



Furthermore, if we want to test properties expecting valid |Html| values as
inputs, we could avoid generating random |Sing| and |Tag| data constructors, as
they might introduce invalid HTML tags.
%
Instead, we could specify that our random data can be constructed only via
``safe'' constructions, using perhaps a representation type like follows:

\begin{code}
type ValidHtml  =      Con_Text oplus'' Con_Join
                oplus  Fun_br oplus'' Fun_bold oplus'' Fun_list oplus'' Fun_cat
\end{code}


The next section introduces a generic way to generate random values from our
different representations, extending them with a set of combinators to encode
information relevant to the generation process directly at the type level.
