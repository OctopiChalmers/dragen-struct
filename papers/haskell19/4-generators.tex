\section{Generating Random Constructions}
\label{sec:generators}

% --------------------------------------
% Intro
%
So far we have seen how to encode different constructions representing
interesting values from our target data types.
%
Such representations follow a modular approach, where each different
construction is considered independent from the rest.
%
This modularity allows us to derive each different construction independently,
as well to specify the shape of our target data with with a fine granularity.


In this section we introduce the machinery required to randomly generate the
values encoded using our representations.
%
For this purpose, this step also follows the modular, fine-grained fashion,
resulting in a generation process entirely compositional.
%
In this light, our random generators are built from smaller ones (each one
representing a single construction), and they are based solely on the types we
use to represent the shape of our random data.

Ideally, our aim is to be able to obtain random generators with a behavior
similar to the one presented for |Html| in Section \ref{sec:sources}.
%
If we take a closer look at its definition, we can observe three factors
happening simultaneously:
%
\begin{itemize}
\item We use the QuickCheck's generation size to limit the depth of the
  generated values, reducing it by one on each recursive call of the local
  auxiliary function |gen|.
\item We differentiate between \emph{terminal} and \emph{non-terminal
    constructors}, limiting our generator to pick only among terminal ones when
  we have reached the maximum depth (case |gen 0|).
\item We generate different constructions in a (possibly) different frequency
  that is fixed over time.
\end{itemize}
%
Then, in order to achieve the desired generation behavior, we will need to model
these previous aspects in our modular framework, and in such a way that we do
not compromise the compositionality obtained so far.


% --------------------------------------
% Depth-bounded generators
%
\subsection{Depth-Bounded Modular Generators}

The first obstacle that arises when trying to generate random values with a
limited depth using our approach is related to modularity.
%
If we recall the random generator for |Html| from Section \ref{sec:sources}, we
can observe that the depth parameter |d| is threaded to the different recursive
call of our generator, but always within the scope of the |gen| local function.
%
Since each construction will have an specialized random generator, we cannot
group them as we did before using an internal |gen| function.
%
Instead, we will define a depth-bounded generator data type, wrapping
QuickCheck's |Gen| data type with a external parameter representing the current
maximum recursive depth:

\begin{code}
type BGen a = Int -> Gen a
\end{code}

A |BGen| is essentially a normal |Gen| with the maximum recursive depth as an
input parameter.
%
Using this previous definition, we can generalize QuickCheck's |Arbitrary| class
to work with depth-bounded generators simply as follows:

\begin{code}
class BArbitrary (a :: *) where
  bounded :: BGen a
\end{code}

From now on, we will use this type class as a more flexibe substitute of
|Arbitrary|, given that now we have two parameters to tune: the maximum
recursive depth, and the QuickCheck generation size.
%
Where the former is useful to tune the overall size of our random data, whereas
the latter can be use for tuning the values of the ``leaves'', such as the
maximum length of random |String| or the maximum/minumum random |Int|s.


Here we want to actively remark that, even though we could have reused the
QuickCheck generation size parameter to simultaneously model the maximum
recursive depth and the maximum size of the leaves, doing so would imply
generating random leaves with a decresing size as we move deeper within a random
value, obtaining for instance, random trees with all zeroes on its leaves, or
random lists showing a hight tendency to be ordered in decreasing order.
%
In addition, one can always obtain a trivial |Arbitrary| instance from a
|BArbitrary| one by using QuickCheck's generation size both for the maximum
recursive depth as well as for generating leaves:

\begin{code}
instance BArbitrary a => Arbitrary a where
  arbitrary = sized bounded
\end{code} %$


Even though we have extended QuickCheck's generators to be depth-aware, here we
also need to consider the parametric nature of our representations.
%
In the previous section, we defined each construction representation as being
parametric on the type of its recursive sub-terms, as a way to defer this choice
until we have specified the overal shape of our target data.
%
Hence, each construction representation is of kind |* -> *|.
%
If we want to define our generators in a modular way, we also need to
parametrize somehow the generation of the recursive subterms!
%
If we look at QuickCheck, this library already defines a type class |Arbitrary1|
for parametric types of kind |* -> *|:

\begin{code}
class Arbitrary1 (f :: * -> *) where
  liftArbitrary :: Gen a -> Gen (f a)
\end{code}

This type class allows us to write modular generators, leaving unspecified the
specific generator used when generating values of its type argument.
%
For instance, the default parametric generator for the data type |Maybe| looks
like:

\begin{code}
instance Arbitrary1 Maybe where
  liftArbitrary gen = frequency
    [  (1,  pure Nothing),  (3,  Just <$> gen) ]
\end{code} %$

Where the random generator use to generate the value stored in a |Just|
constructor is parametrized by the |gen| input variable.
%
We can use this same mechanism for our modular generators, first extending it to
be depth-aware as follows:

\begin{code}
class BArbitrary1 (f :: * -> *) where
  liftBGen :: BGen a -> BGen (f a)
\end{code}
%
Note the similarity between the |Arbitrary1| and |BArbitrary1| type classes.
%
Then, we will use this type class to implement random generators for each
construction we are considering.
%
Recalling our |Html| example, we can define modular random generator for the
constructions representing data constructors as follows:

\begin{code}
instance BArbitrary1 Con_Text where
  liftBGen gen d = Con_Text <$> arbitrary

instance BArbitrary1 Con_Sing where
  liftBGen gen d = Con_Sing <$> arbitrary

instance BArbitrary1 Con_Tag where
  liftBGen gen d = Con_Tag <$> arbitrary <*> gen (d - 1)

instance BArbitrary1 Con_Join where
  liftBGen gen d = Con_Join <$> gen (d - 1) <*> gen (d - 1)
\end{code} %$

Note in the previous definitions how each instance is defined to be independent
of the maximum depth (paramtrized by the input variable |d|) and the random
generator used for the recursive sub-terms (parametrized by the input variable
|gen|).
%
Every other non-recursive sub-term can be generated using a normal |Arbitrary|
instance---we use this to generate random |String|s in the previous definitions.


The rest of our construction representations can be generated analogously.
%
For example, the |BArbitrary1| instances for |Fun_bold| and |Pat_simplify_2| are
as follows:

\begin{code}
instance BArbitrary1 Fun_bold where
  liftBGen gen d = Fun_bold <$> gen (d - 1)

instance BArbitrary1 Pat_simplify_2 where
  liftBGen gen d = Pat_simplify_2  <$> arbitrary
                                   <*> gen (d - 1)
                                   <*> gen (d - 1)
\end{code} %$

% \begin{code}
% instance BArbitrary1 Fun_br where
%   liftBGen gen d = pure Fun_br

% instance BArbitrary1 Fun_bold where
%   liftBGen gen d = Fun_bold <$> gen (d - 1)

% instance BArbitrary1 Fun_cat where
%   liftBGen gen d = Fun_cat <$> gen (d - 1) <*> gen (d - 1)

% instance BArbitrary1 Fun_list where
%   liftBGen gen d = Fun_list <$> liftArbitrary (gen (d - 1))
% \end{code} %$

% \begin{code}
% instance BArbitrary1 Pat_simplify_1 where
%   liftBGen gen d
%     = Pat_simplify_1 <$> arbitrary <*> arbitrary

% instance BArbitrary1 Pat_simplify_2 where
%   liftBGen gen d
%     = Pat_simplify_2 <$> gen (d - 1) <*> gen (d - 1)
% \end{code}

Having all the modular generators for each construction in place, we can finally
obtain a concrete depth-aware generator (of kind |*|) for any final
representation |f| as follows:

\begin{code}
instance BArbitrary1 f => BArbitrary (Fix f) where
  bounded d = Fix <$> liftBGen bounded d
\end{code} %$

The previous instance employs the |BArbitrary1| of our final representation to
generate sub-terms recursively using itself (|bounded d|) as the parametrized
input generator, wrapping each recursive sub-term with a |Fix| data constructor.

%
% Wrapping this subsection
%
The machinery developed so far lets us generate single random constructions in a
modular fashion.
%
However, we still need to develop our generation mechanism a bit further in
order to generate composite representations built using the |oplus| type-level
operator.
%
This is the objective of the next sub-section.

% --------------------------------------
% Encoding Generation Behavior Using Types
%
\subsection{Encoding Generation Behavior Using Types}

As we have shown so far, generating each construction representation is rather
straightforward: there is only one data constructor to select, and every field
is generating following a mechanical recipe.
%
In our approach, most of the generation complexity is encoded in the random
generator used for composite representations built upon the |oplus| operator.
%
Before introducing it, we need to define some additional machinery to encode the
notions of terminal construction and generation frequency.


Recalling the random generator for |Html| presented in Section
\ref{sec:sources}, we can observe that the last generation level (see |gen 0|)
is constrained to generate only the non-recursive subset of all the available
constructions.
%
In order to model this behavior in our framework, we can start by defining a
data type |Term| to ``tag'' every terminal construction explicitly:

\begin{code}
newtype Term (f :: * -> *) a = Term (f a)
\end{code}

Then, if |f| is a non-recursive construction, the type |Term f oplus' g| can be
interpreted as representing values generated using values drawn both from |f|
and |g|, but ``closed'' using only values from |f|.
%
Since this data type will not add any semantic information to our represented
values, we can define suitable |Algebra| and |BArbitrary1| instances for it
simply by delegating the work to the inner type:

\begin{code}
instance Algebra f a => Algebra (Term f) a where
  alg (Term f) = alg f

instance BArbitrary1 f => BArbitrary1 (Term f) where
  liftBGen gen d = Term <$> liftBGen gen d
\end{code} %$


The next building block of our framework consists in a way of specifying the
generation frequency of each construction.
%
For this purpose, we can follow the same reasoning as before, defining a data
type-level operator |otimes| to explicitly tag the generation frequency of a
given representation:

\begin{code}
newtype ((f :: * -> *) otimes'' (n :: Nat)) a = Freq (f a)
\end{code}

In the definition above, the operator |otimes| is parametrized by a type-level
natural number |n| (of kind |Nat|) representing the desired generation
frequency.
%
In this light, the type |(f otimes'' 3) oplus'' (g otimes'' 1)| represents
values generated using values from both |f| and |g|, where |f| is randomly
chosen three times more frequently than |g|.
%
In practice, we defined |otimes| such that it associates more strongly than
|oplus|, thus avoiding the need of parenthesis in types like the previous one.
%
Analogously as |Term|, the operator |otimes| does not add any semantic
information to the values it represents, so we can define its |Algebra| and
|BAbitrary1| instance by delegating the work to the inner type as before:

\begin{code}
instance Algebra f a => Algebra (f otimes'' n) a where
  alg (Freq f) = alg f

instance BArbitrary1 f => BArbitrary1 (f otimes'' n) where
  liftBGen gen d = Freq <$> liftBGen gen d
\end{code} %$


With these two new type level combinators |Term| and |otimes|, we are now able
to express the behavior of our entire generation process based solely on the
type we are generating.
%
In addition to these combinators, we will need to perform some type-level
computations based on them in order to define our random generator for composite
representations.
%
Consider for instance the following type defined using parenthesis for clarity:

\begin{code}
(f otimes'' 2) oplus'' ((g otimes'' 3) oplus'' (Term h))
\end{code}

Our generation process will traverse this type one combinator at a time,
processing each occurrence of |oplus| independently.
%
This means that, in order to select the appropriate generation frequency of each
operand we need to calculate the overall sum of frequencies on each side of the
|oplus|.
%
For this purpose, we can implement a closed type family |FreqOf| to compute the
overal sum of frequencies of a given representation type:

\begin{code}
type family FreqOf (f :: * -> *) :: Nat where
  FreqOf (f oplus'' g)   = FreqOf f + FreqOf g
  FreqOf (f otimes'' n)  = n * FreqOf f
  FreqOf (Term f)        = FreqOf f
  FreqOf _               = 1
\end{code}

This type-level function takes a representation type as an input and traverses
it recursively, adding up each frequency tag found in the process, and returning
a type-level natural number.
%
Note how in the second equation we multiply the frequency encoded in the
|otimes| tag with the frequency of the type it is wrapping.
%
This way, the type |((f otimes'' 2) oplus'' g) otimes'' 3| is equivalent to |(f
otimes'' 6) oplus'' (g otimes'' 3)|, following the natural intuition for the
addition and multiplication operations over numbers.
%
Moreover, if a type does have an explicit frequency then its frequency is simply
defaulted to one.


On the other hand, the last step of our generation process which only generates
terminal constructions could be seen as generating values considering all the
available constructions, but instead treating the non-terminal ones as having
generation frequency zero.
%
This way we can reuse our previous type level computation to calculate the
\emph{terminal generation frequency} |FreqOf'| of a given representation type as
follows:

\begin{code}
type family FreqOf' (f :: * -> *) :: Nat where
  FreqOf' (f oplus'' g)   = FreqOf' f  +  FreqOf' g
  FreqOf' (f otimes'' n)  = n  *  FreqOf' f
  FreqOf' (Term f)        = FreqOf f
  FreqOf' _               = 0
\end{code}

Similar to |FreqOf|, the type family above traverses its input type adding the
terminal frequency of each sub-type.
%
However, |FreqOf'| only considers the frequency of those representation
sub-types that are explicitly tagged as terminal, returning zero in any other
case.


Using the typle level combinators introduced at the beginning of this
sub-section along with the previous type-level computations over frequencies, we
are finally in position of defining our random generator for composite
representations:

\begin{code}
instance (BArbitrary1 f, BArbitrary1 g)
  => BArbitrary1 (f oplus g) where
  liftBGen gen d =
    if d > 0
    then frequency
      [ (freqVal  at(FreqOf f) ,  InL <$> liftBGen gen d)
      , (freqVal  at(FreqOf g) ,  InR <$> liftBGen gen d) ]
    else frequency
      [ (freqVal  at(FreqOf' f) ,  InL <$> liftBGen gen d)
      , (freqVal  at(FreqOf' g) ,  InR <$> liftBGen gen d) ]
\end{code}

Like the generator introduced in Section \ref{sec:sources} for |Html|, this
generator branches over the current generation depth |d|.
%
In the case we can still generate values from any construction (|d > 0|), we
will use QuickCheck's |frequency| operation to randomly choose between
generating a value of each side of the |oplus|, i.e., either a value of |f| or a
value of |g|, following the generation frequencies specified for both of them,
and wrapping the values with the appropriate injection |InL| or |InR| on each
case.
%
Such frequencies are obtained by \emph{reflecting} the type-level natural values
obtained from applying |FreqOf| to both |f| and |g|, using a type-dependent
function |freqVal| that returns the number corresponding to the type-level
natural value we apply to it:

\begin{code}
freqVal :: forall n dot KnownNat n => Int
\end{code}

Note that the type of |freqVal| is ambiguous, since it quantifies over every
possible known type-level natural value |n|.
%
We need to use a \emph{visible type application} (employing the |at (...)|
syntax) to desambiguate which type-level natural value we are refering to.
%
Then, for instance, the value |freqVal at (FreqOf (f otimes'' 5))| will evaluate
to |5 :: Int|.

The remaining part of our random generator works analogously, except that this
time we only want to generate terminal constructions, hence we use the |FreqOf'|
type family to compute the terminal generation frequency of each operand.
%
If any of |FreqOf' f| or |FreqOf' g| evaluates to zero, then it means that that
operand does not contain any terminal constructions, and |frequency| will not
consider it when generating terminal values.

If it happens that both |FreqOf' f| and |FreqOf' g| compute to zero when
genrating a composite value, then it will produce a runtime error triggered by
the function |frequency|, as it does not have anything with a positive frequency
to generate.
%
This kind of exceptions will arise for examplke if we forget to tag at least a
single construction within a composite representation as terminal.
%
Fortunately, such runtime exceptions can be catched in compile-time by defining
a type constraint that ensures we are trying to generate values using a
representation with a strictly positive terminal generation frequency---thus
containing at least a single terminal construction:

\begin{code}
type family HasTerminals (f :: * -> *) :: Constraint where
  HasTerminals f = IsPositive (FreqOf' f)

type family IsPositive (n :: Nat) :: Constraint where
  IsPositive 0 = TypeError "No terminals"
  IsPositive _ = ()
\end{code}
%
The previous type families compute the terminal generation frequency of a
representation type |f|, returning a type error if its result is zero, or an
empty constraint |()| that is always trivially satisfied in any other case.
%
Finally, we can use this constraint to define a safe generation primitive
|genEval| to obtain a random depth-bounded generator for every target type |a|
specified using a safe generation representation |f|:

\begin{code}
genEval  :: forall f a dot
  (BArbitrary1 f, HasTerminals f, Algebra f a) => BGen a
genEval d = eval <$> bounded at (Fix f) d
\end{code} %$

Note how this primitive is also ambiguous in the type used for the
representation.
%
This allows us to use a visible type application to obtain values from the same
target type but generated using a different underlying representations.
%
For instance, we can obtain two different concrete generators for our |Html|
type simply by changing its representation type as follows:

\begin{code}
genHtmlPats :: BGen Html
genHtmlPats = genEval at Html_simplify

genValidHtml :: BGen Html
genValidHtml = genEval  at ValidHtml
\end{code}

Where |Html_simplify| and |ValidHtml| are the types defined at the end of
Section \ref{sec:representation}.


% --------------------------------------
% Closing
%
So far we have seen how to represent and generate values for a target data type
by combining a wide selection of structural constructions, as well as a series
of type-level combinators to encode the generation behavior.
%
The next section refines our type-level machinery in order to export an elegant
domain specific language for specifying composable random generators.
