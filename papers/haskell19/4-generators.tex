\section{Generating Random Constructions}
\label{sec:generators}


\begin{code}
type BGen a = Int -> Gen a

class BArbitrary (a :: *) where
  bounded :: BGen a
\end{code}


\begin{code}
class Arbitrary1 (f :: * -> *) where
  liftGen :: Gen a -> Gen (f a)
\end{code}

\begin{code}
class BArbitrary1 (f :: * -> *) where
  liftBGen :: BGen a -> BGen (f a)
\end{code}

\begin{code}
data ((f :: * -> *) otimes (n :: Nat)) a = Freq (f a)
\end{code}

\begin{code}
data Term (f :: * -> *) a = Term (f a)
\end{code}

\begin{code}
instance Algebra f a => Algebra (f otimes n) a where
  alg (Freq f) = alg f
\end{code}

\begin{code}
instance Algebra f a => Algebra (Term f) a where
  alg (Term f) = alg f
\end{code}


\begin{code}
instance BArbitrary1 f => BArbitrary1 (f otimes n) where
  liftBGen gen d = Freq <$> liftBGen gen d

instance BArbitrary1 f => BArbitrary1 (Term f) where
  liftBGen gen d = Term <$> liftBGen gen d
\end{code}

\begin{code}
type family FreqOf (f :: * -> *) :: Nat where
  FreqOf (f oplus g)   = FreqOf f + FreqOf g
  FreqOf (f otimes n)  = n * FreqOf f
  FreqOf (Term f)      = FreqOf f
  FreqOf _             = 1
\end{code}

\begin{code}
type family FreqOf' (f :: * -> *) :: Nat where
  FreqOf' (f oplus g)   = FreqOf' f  +  FreqOf' g
  FreqOf' (f otimes n)  = n  *  FreqOf' f
  FreqOf' (Term f)      = FreqOf f
  FreqOf' _             = 0
\end{code}


\begin{code}
instance (BArbitrary1 f, BArbitrary1 g)
  => BArbitrary1 (f oplus g) where
  liftBGen gen d =
    if d > 0
    then frequency
      [ (freqVal  at(FreqOf f) ,  InL <$> liftBGen gen d)
      , (freqVal  at(FreqOf g) ,  InR <$> liftBGen gen d) ]
    else frequency
      [ (freqVal  at(FreqOf' f) ,  InL <$> liftBGen gen d)
      , (freqVal  at(FreqOf' g) ,  InR <$> liftBGen gen d) ]
\end{code}

\begin{code}
freqVal :: forall n dot KnownNat n => Int
\end{code}

\begin{code}
instance BArbitrary1 Con_Text where
  liftBGen gen d = Con_Text <$> arbitrary

instance BArbitrary1 Con_Sing where
  liftBGen gen d = Con_Sing <$> arbitrary

instance BArbitrary1 Con_Tag where
  liftBGen gen d = Con_Tag <$> arbitrary <*> gen (d - 1)

instance BArbitrary1 Con_Join where
  liftBGen gen d = Con_Join <$> gen (d - 1) <*> gen (d - 1)
\end{code} %$


\begin{code}
instance BArbitrary1 Fun_br where
  liftBGen gen d = pure Fun_br

instance BArbitrary1 Fun_bold where
  liftBGen gen d = Fun_bold <$> gen (d - 1)

instance BArbitrary1 Fun_cat where
  liftBGen gen d = Fun_cat <$> gen (d - 1) <*> gen (d - 1)

instance BArbitrary1 Fun_list where
  liftBGen gen d = Fun_list <$> liftGen (gen (d - 1))
\end{code} %$

\begin{code}
instance BArbitrary1 Pat_simplify_1 where
  liftBGen gen d
    = Pat_simplify_1 <$> arbitrary <*> arbitrary

instance BArbitrary1 Pat_simplify_2 where
  liftBGen gen d
    = Pat_simplify_2 <$> gen (d - 1) <*> gen (d - 1)
\end{code}


\begin{code}
instance BArbitrary1 f => BArbitrary (Fix f) where
  bounded d = Fix <$> liftBGen bounded d
\end{code} %$

\begin{code}
genFix  ::  forall f dot BArbitrary1 f =>  BGen (Fix f)
genFix d = bounded at(Fix f) d
\end{code}

\begin{code}
genEval :: forall f a dot (BArbitrary1 f, Algebra f a) => BGen a
genEval d = eval <$> genFix at f d
\end{code} %$