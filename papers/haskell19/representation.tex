\section{Unified Representation of Constructions}
\label{sec:representation}

Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Donec hendrerit tempor
tellus. Donec pretium posuere tellus. Proin quam nisl, tincidunt et, mattis
eget, convallis nec, purus. Cum sociis natoque penatibus et magnis dis
parturient montes, nascetur ridiculus mus. Nulla posuere. Donec vitae dolor.
Nullam tristique diam non turpis. Cras placerat accumsan nulla. Nullam rutrum.
Nam vestibulum accumsan nisl.

\begin{code}
class Arbitrary (a :: *) where
  arbitrary :: Gen a
\end{code}

\begin{code}
class Arbitrary1 (f :: * -> *) where
  liftGen :: Gen a -> Gen (f a)
\end{code}

\begin{code}
instance Arbitrary Html where
  arbitrary = sized gen
    where
      gen 0 = frequency
        [  (2,  Text    <$> arbitrary)
        ,  (1,  Single  <$> arbitrary) ]
      gen n = frequency
        [  (2,  Text    <$> arbitrary)
        ,  (1,  Single  <$> arbitrary)
        ,  (4,  Tag     <$> arbitrary  <*> gen (n-1))
        ,  (3,  Join    <$> gen (n-1)  <*> gen (n-1)) ]
\end{code} %$

\begin{code}
type BoundedGen a = Int -> Gen a

class BoundedArb (a :: *) where
  boundedArb :: BoundedGen a
\end{code}

\begin{code}
data ((f :: * -> *) oplus (g :: * -> *)) a = InL (f a) | InR (g a)
\end{code}

\begin{code}
data ((f :: * -> *) otimes (n :: Nat)) a = Freq (f a)
\end{code}

\begin{code}
data Term (f :: * -> *) a = Term (f a)
\end{code}

\begin{code}
  data Fix (f :: * -> *) = Fix { unFix :: (f (Fix f)) }
\end{code}

\begin{code}
class Functor f => Algebra f a | f -> a where
  alg :: f a -> a
\end{code}

% cata :: Functor f => (f a -> a) -> Fix f -> a
% cata f = f . fmap (cata f) . unFix

\begin{code}
eval :: Algebra f a => Fix f -> a
eval = alg . fmap eval . unFix
\end{code}


\begin{code}
instance (Algebra f a, Algebra g a) => Algebra (f oplus g) a
  where  alg (InL f) = alg f
         alg (InR g) = alg g

instance Algebra f a => Algebra (f otimes n) a
  where alg (Freq f) = alg f

instance Algebra f a => Algebra (Term f) a
  where alg (Term f) = alg f
\end{code}


\begin{code}
data Con_Text   r = Con_Text String
data Con_Sing   r = Con_Sing String
data Con_Tag    r = Con_Tag  String r
data Con_infix  r = Con_infix r r
\end{code}

\begin{code}
data Fun_br     r = Fun_br
data Fun_bold   r = Fun_bold r
data Fun_infix  r = Fun_infix r r
data Fun_list   r = Fun_list [r]
\end{code}

\begin{code}
data Pat_simplify_1 r = Pat_simplify_1 String String
data Pat_simplify_2 r = Pat_simplify_2 String r r
\end{code}

\begin{code}
instance Algebra Con_Text Html where
  alg (Con_Text x) = Text x

instance Algebra Con_Sing Html where
  alg (Con_Sing x) = Sing x

instance Algebra Con_Tag Html where
  alg (Con_Tag t x) = Tag t x

instance Algebra Con_infix Html where
  alg (Con_infix x y) = x :+: y
\end{code}

\begin{code}
instance Algebra Fun_br Html where
  alg Fun_br = br

instance Algebra Fun_bold Html where
  alg (Fun_bold x) = bold x

instance Algebra Fun_infix Html where
  alg (Fun_infix x y) = x <+> y

instance Algebra Fun_list Html where
  alg (Fun_list xs) = list xs
\end{code}

\begin{code}
instance Algebra Pat_simplify_1 Html where
  alg (Pat_simplify_1 t1 t2) = Text t1 :+: Text t2

instance Algebra Pat_simplify_2 Html where
  alg (Pat_simplify_1 t x y) = (Text t :+: x) :+: y
\end{code}


\begin{code}
instance BoundedArb1 Con_Text where
  liftBounded gen lvl = Con_Text <$> arbitrary

instance BoundedArb1 Con_Sing where
  liftBounded gen lvl = Con_Sing <$> arbitrary

instance BoundedArb1 Con_Tag where
  liftBounded gen lvl
    = Con_Tag <$> arbitrary <*> gen (lvl - 1)

instance BoundedArb1 Con_infix where
  liftBounded gen lvl
    = Con_infix <$> gen (lvl - 1) <*> gen (lvl - 1)
\end{code} %$

\begin{code}
instance BoundedArb1 Fun_br where
  liftBounded gen lvl = pure Fun_br

instance BoundedArb1 Fun_bold where
  liftBounded gen lvl = Fun_bold <$> gen (lvl - 1)

instance BoundedArb1 Fun_infix where
  liftBounded gen lvl
    = Fun_infix <$> gen (lvl - 1) <*> gen (lvl - 1)

instance BoundedArb1 Fun_list where
  liftBounded gen lvl
    = Fun_list <$> liftGen (gen (lvl - 1))
\end{code} %$

\begin{code}
instance BoundedArb1 Pat_simplify_1 where
  liftBounded gen lvl
    = Pat_simplify_1 <$> arbitrary <*> arbitrary

instance BoundedArb1 Pat_simplify_2 where
  liftBounded gen lvl
    = Pat_simplify_2 <$> gen (lvl - 1) <*> gen (lvl - 1)
\end{code}


\begin{code}
instance BoundedArb1 f => BoundedArb1 (f otimes n) where
  liftBounded gen lvl = Freq <$> liftBounded gen lvl

instance BoundedArb1 f => BoundedArb1 (Term f) where
  liftBounded gen lvl = Term <$> liftBounded gen lvl
\end{code}


\begin{code}
type family FreqOf (f :: * -> *) :: Nat where
  FreqOf (f oplus g)   = FreqOf f + FreqOf g
  FreqOf (f otimes n)  = n * FreqOf f
  FreqOf (Term f)      = FreqOf f
  FreqOf _             = 1
\end{code}

\begin{code}
type family FreqOf' (f :: * -> *) :: Nat where
  FreqOf' (f oplus g)   = FreqOf' f  +  FreqOf' g
  FreqOf' (f otimes n)  = n  *  FreqOf' f
  FreqOf' (Term f)      = FreqOf f
  FreqOf' _             = 0
\end{code}


\begin{code}
instance (BoundedArb1 f, BoundedArb1 g)
  => BoundedArb1 (f oplus g) where
  liftBounded gen lvl =
    if lvl > 0
    then frequency
    [ (natVal  at(FreqOf f) ,  InL <$> liftBounded gen lvl)
    , (natVal  at(FreqOf g) ,  InR <$> liftBounded gen lvl) ]
    else frequency
    [ (natVal  at(FreqOf' f) ,  InL <$> liftBounded gen lvl)
    , (natVal  at(FreqOf' g) ,  InR <$> liftBounded gen lvl) ]
\end{code}


\begin{code}
class BoundedArb1 (f :: * -> *) where
  liftBounded :: BoundedGen a -> BoundedGen (f a)
\end{code}

\begin{code}
instance BoundedArb1 f => BoundedArb (Fix f) where
  boundedArb lvl = Fix <$> liftBounded boundedArb lvl
\end{code} %$

\begin{code}
genFix  ::  forall f dot BoundedArb1 f =>  BoundedGen (Fix f)
genFix lvl = boundedArb at(Fix f) lvl
\end{code}

\begin{code}
genEval :: forall f a dot (BoundedArb1 f, Algebra f a) =>  BoundedGen a
genEval lvl = eval <$> genFix at f lvl
\end{code} %$


\begin{code}
data Some (f :: * -> * -> *) (r :: *) = forall (a :: *) dot Some (f a r)
\end{code}

\begin{code}
type family (t :: * -> *) apply (a :: *) :: * -> *  where
  (Some t)      apply  a  = t a
  (f oplus g)   apply  a  = (f apply a) oplus (g apply a)
  (f otimes n)  apply  a  = (f apply a) otimes n
  (Term t)      apply  a  = Term (t apply a)
  t             apply  a  = t
\end{code}

\begin{code}
type family Rep (t :: Symbol) :: * -> *

type family Con (c :: Symbol) :: * -> *
type family Fun (f :: Symbol) :: * -> *
type family Pat (p :: Symbol) (n :: Nat) :: * -> *

type Con' a    = Term  (Con a)
type Fun' a    = Term  (Fun a)
type Pat' a n  = Term  (Pat a n)
\end{code}

\begin{code}
type HtmlSpec
  =      Con'  "Text"
  oplus  Con   "Join"         otimes 2
  oplus  Fun'  "br"           otimes 4
  oplus  Fun   "<+>"          otimes 9
  oplus  Pat   "simplify"  1  otimes 3
  oplus  Pat   "simplify"  2  otimes 5
\end{code}