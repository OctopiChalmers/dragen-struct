\section{Random Testing with Source Hints}
\label{sec:sources}

In this section, we briefly introduce the motivation for including extra
information into our random generators, and discuss about how this can be
implemented in practice.


% --------------------------------------
% Abstract interfaces
%
\subsection{Extracting Information From Interfaces}

A common choice when implementing abstract data types is to transfer the
responsibility of preserving their invariants to the functions on their abstract
interface.
%
Take for example our |Html| data type.
%
Instead of defining a different data constructor for each possible HTML tag, we
opted for a very small generic representation that can be extended via a set of
combinators making use of this basic interface:

\begin{code}
br :: Html
br = Sing "br"

bold :: Html -> Html
bold = Tag "b"

list :: [Html] -> Html
list []  = Text "empty list"
list xs  = Tag "ul" $ foldl1 Join (Tag "li" <$> xs)

(<+>) :: Html -> Html -> Html
(<+>) x y = Join x (Join br y)
\end{code} %$
%
These functions let us encode structured HTML constructions like line-breaks
(|br|), bold blocks (|bold|), unordered lists (|list|) and concatenation of
values one below another (|<+>|).
%
\looseness=-1

Note how difficult would it be to generate random values containing, for
example, structurally valid HTML lists if we only consider the structural
information encoded in our |Html| type definition.
%
After all, much of the valid structure of HTML has been encoded on its abstract
interface.


Then, an automatically derived generator could integrate this structural
information into the generation process by creating random values arising from
applying such functions to randomly generated inputs:

\begin{code}
  gen d = frequency
    [ ...
    , (1, pure br)
    , (5, bold   <$> gen (d-1))
    , (2, list   <$> listOf (gen (d-1)))
    , (3, (<+>)  <$> gen (d-1) <*> gen (d-1)) ]
\end{code}%$
%
where the symbol (|...|) represents the rest of the possible choices of data
constructors seen before.
%
From now on, we will refer to each possible choice given to |frequency| as a
different \emph{random construction}, as we are not considering generating only
single data constructors anymore.

% --------------------------------------
% Functions' pattern matchings
%
\subsection{Extracting Information From Patterns}

A different challenge appears when we try to test functions comprising complex
pattern matchings. Consider for instance the following function for simplifying
|Html| values:

\begin{code}
simplify :: Html -> Html
simplify (Join (Text t1) (Text t2)) = Text (t1 ++ t2)
simplify (Join (Join (Text t) x) y)
  = simplify (Text t1 iJoin simplify (x iJoin y))
simplify (Join x y) = simplify x iJoin simplify y
simplify (Tag t x) = Tag t (simplify x)
simplify x = x
\end{code}
%
This function simply traverses |Html| values, joining together every contiguous
pair of |Text| constructors.
%
Ideally, we would like to put approximately the same testing effort info each
clause of |simplify|, or perhaps even more to the first two ones, since those
are the ones performing actual simplifications.
%
However, these two clauses are the most difficult ones to test in practice!
%
The probability of generating a random value satisfying nested patterns
decreases multiplicatively with the number of constructors we simultaneously
pattern match against to.


In our tests, we were not able to exercise any of these two patterns more than
6\% of the overall testing time (and considering recursive sub-calls), using
random generators derived using either \emph{MegaDeTH} and \emph{DRAGEN}.
%
As expected, most of the random test cases were exercising the simplest (an
rather uninteresting) patterns of this function, corresponding to its last three
clauses.


To solve this issue, we could opt to consider each complex pattern as a new kind
of random construction.
%
In this light, we can simply generate values satisfying patterns directly by
returning their corresponding expressions, where each variable or wildcard
pattern is filled using a random sub-expression:

\begin{code}
  gen d = frequency
    [ ...
    , (2, do  t1  <- arbitrary
              t2  <- arbitrary
              return (Text t1 iJoin Text t2))
    , (4, do  t2  <- arbitrary
              x   <- go (d-1)
              y   <- go (d-1)
              return ((Text t1 iJoin x) iJoin y))]
\end{code}%$


% --------------------------------------
% Wrapping up
%
In general, we think that including this static information in our generators
directly is far from ideal, as in many cases we would like to select which
random constructions are of our interest when testing different properties or
sub-systems.
%
In this light, having ``monolithic'' random generators derived automatically
would complicate our desired workflow.
%
We would need to derive different concrete random generators for each use case
instead of having a single |Arbitrary| instance that can be used everywhere.


In contrast, in this work we opted for developing an extensible mechanism, where
the generation machinery is automatically derived just once, and every variant
of our random generators is expressed at the type-level.
%
The following sections of this paper cover our alternative approach in depth.
