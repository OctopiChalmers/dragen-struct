\section{Related Work}
\label{sec:related}

\citeauthor{SwierstraDTC} \cite{SwierstraDTC} proposes the Data Types \`a la
Carte approach for building extensible data types and unified interpreters as a
solution for the expression problem coined by \citeauthor{wadler1998expression}
\cite{wadler1998expression}.
%
In this work, we take ideas from this approach and extend them to work in the
scope of random data generation, where other parameters come into play apart
from just combining construction, e.g., generation frequency and terminal
constructions.


From the practical point of view, \citeauthor{KiriyamaOptimizingDTC} propose an
optimization mechanism for Data Types \`a Carte, where a concrete data type has
to be derived for each different composition of constructions defined by the
user \cite{KiriyamaOptimizingDTC}.
%
This solution avoids much of the runtime overhead introduced when internally
pattern matching against sequencies of |InL| and |InR| data constructors.
%
However, we see this solution as not entirely compositional, since we still need
to rely on Template Haskell to derive the machinery for each specialized data
type.
%
In our particular setting, we found that our solution has a fairly acceptable
overhead by automatically balancing our representation types.


In the past few years, there has been a bloom of derivation tools for
synthesizing random generators.
%
\emph{Feat} provides a mechanism to uniformly generate values from a given data
type \cite{DuregardJW12}.
%
It works by enumerating all the possible values of such type, so that sampling
uniformly from it simply becomes sampling uniformly from the a finite preffix of
natural numbers.


\emph{MegaDeTH} is a simple derivation tool that derives generators solely based
on their types, and paying no attention whatsoever on the generation frequency
of each data constructor.
%
As a result, its automatically derived generators has been shown to be skewed to
generating small values\cite{DBLP:conf/haskell/MistaRH18}.


On the other hand, \emph{DRAGEN} is a tool that synthesizes optimized
generators, tuning their generation frequencies using a simulation-based
optimization process parametrized by the distribution of values desired by the
user \cite{DBLP:conf/haskell/MistaRH18}.
%
This simulation is based on the theory of \emph{branching processes}, which
models the growth and extinction of populations across succesive generations.
%
In this setting, populations consist of randomly generated data constructors,
where generations correspond to each level of the generated values.
%
This tool has shown to improve the code coverage obtained over our codebase,
with respect to other fully-automated generators derivation mechanism.
%
In a recent work, \citeauthor{Mista2019GeneratingRS} extend this approach to
generate random values considering also the other sources of structural
information covered here, namely abstract interfaces and function pattern
machings.
%
The authors of this work focus on the generation model problem, extending the
theory of branching processes in order to obtain sound predictions about
distributions of random values considering these new kinds of constructions.
%
Using this extension, they show that using extra information when generating
random values is extremely valuable, in particular under situations like the
ones described in Section \ref{sec:sources}, where the usual derivation
approaches fail to synthesize useful generators due to a lack of structural
information.


This paper tackles the representation problem, demonstrating how a compositional
generation process can be effectively implemented and automated in Haskell using
advanced type-level features.
%
Since none of the aforementioned tools are designed for composability, we
consider that our ideas could perhaps be applied to improve these tools in the
future.
