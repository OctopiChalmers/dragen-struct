\section{Introduction}
\label{sec:intro}

% --------------------------------------
% Intro
%
Random property-based testing is a powerful technique for finding bugs
~\cite{ArtsHNS15, HughesPAN16, HughesNSA16, MidtgaardJKNN17}.
%
In the Haskell community, QuickCheck is the predominant tool for that task
\cite{ClaessenH00}.
%
The developers specify
%
\begin{inparaenum}[(i)]
\item the testing properties their systems must fulfill, and
\item random data generators (or generators for short) for the data types
  involved at their properties.
\end{inparaenum}
%
Then, QuickCheck generates random values using these generators, and uses them
to evaluate the testing properties in search of possible counterexamples, which
often indicate the presence of bugs.


% --------------------------------------
% Motivating Example
%
Although QuickCheck provides default generators for the common base types, like
|Int| or |String|, it requires implementing generators for any user-defined data
type we want to generate.
%
% This section introduces the common workflow for generating random values using
% automatically derived QuickCheck generators, along with its common limitations.
%
To illustrate this, let us consider the following data type definition encoding
basic HTML pages:

\begin{code}
data Html  =  Text  String
           |  Sing  String
           |  Tag   String Html
           |  Join  Html Html
\end{code}
%
This type allows us to build HTML pages via four possible data constructors:
|Text| is used for plain text values; |Sing| and |Tag| represent singular and
paired HTML tags, respectively; and |Join| simply concatenates two HTML pages
one after another.
%
Note that the constructors |Tag| and |Join| are recursive, as they have at least
one field of their own type.
%
In this paper, we will refer to any recursive data constructor as
\emph{non-terminal}, and as \emph{terminal} in any other case.


Using this representation, the example page:

\begin{code}
ExampleHTML
\end{code}
%
can be encoded as:
%
\begin{code}
Tag "html" $ Tag "b" $
  Text "hello" iJoin Sing "br" iJoin Text "world!"
\end{code} %$

% --------------------------------------
% Random Generators
%
As mentioned before, in order to generate random |Html| values, we need to
provide a random generator for it.
%
For this purpose, QuickCheck defines the |Arbitrary| type-class for defining
default generators as:

\begin{code}
class Arbitrary (a :: *) where
  arbitrary :: Gen a
\end{code}
%
where the overloaded symbol |arbitrary :: Gen a| denotes a monadic generator for
values of type |a|.
%
Using this mechanism, we can define a sensible random generator for our |Html|
data type as follows:

\begin{code}
instance Arbitrary Html where
  arbitrary = sized gen
    where  gen 0 = frequency
             [  (2,  Text    <$> arbitrary)
             ,  (1,  Sing    <$> arbitrary) ]
           gen d = frequency
             [  (2,  Text    <$> arbitrary)
             ,  (1,  Sing    <$> arbitrary)
             ,  (4,  Tag     <$> arbitrary  <*> gen (d-1))
             ,  (3,  Join    <$> gen (d-1)  <*> gen (d-1)) ]
\end{code} %$
%
At the top level, this definition parametrizes the generation process using
QuickCheck's |sized| combinator, which lets us build our generator via an
auxiliary local function |gen :: Int -> Gen Html|.
%
The |Int| passed to |gen| is known as the \emph{generation size}, and is
threaded seamlessly by QuickCheck on each call to arbitrary.
%
Then, we use this parameter to limit the maximum amount of recursive calls that
our generator can perform, and thus the maximum depth of the generated values.
%
If the generation size is positive (case |gen d|), our random generator picks a
random |Html| constructor with a given generation frequency (using QuickCheck's
|frequency| combinator), and proceeds to fill its fields using randomly
generated sub-terms---here using Haskell's applicative notation
\cite{Mcbride2008} and the default |Arbitrary| instance for |String|s.
%
For the case of the recursive sub-terms, this generator simply calls the
function |gen| recursively with a smaller generation size (|gen (d-1)|).
%
This process repeats until we reach the base case (|gen 0|) on each recursive
sub-term.
%
At this point, the generator is limited to pick only among terminal |Html|
constructors, hence ending the generation process.


% --------------------------------------
% Automatic derivation tools
%
As one can observe, the previous definition is quite mechanical, and depends
only on the generation frequencies we choose for each constructor.
%
Fortunately, there exists a variety of tools for obtaining random generators
automatically, based on the information encoded on the definition of the types
we want to generate.
%
Most of them implemented using Haskell's meta-programming framework named
Template Haskell \cite{SheardJ02}.
%
For instance, tools like \emph{MegaDeTH} \cite{GriecoCB16, grieco2017} or
\emph{DRAGEN} \cite{DBLP:conf/haskell/MistaRH18} will synthesize random
generators using roughly the same generation procedure as the one shown above.
%
On one hand, \emph{MegaDeTH} derives generators which simply pick among data
constructors with uniform probabilities, whereas \emph{DRAGEN} analyzes type
definitions, tuning the generation frequencies based on a predictive mechanism.
%
This allows the users to specify the desired distribution of values produced by
the derived generators.
%
\looseness=-1

% --------------------------------------
% Limitation
%
These tools provide a useful mechanism for automating the repetitive and
error-prone task of writing random generators by hand.
%
However, this simple derivation procedure, which
%
\begin{inparaenum}[(i)]
\item only considers the structural information encoded in type definitions, and
\item generates one single constructor at a time;
\end{inparaenum}
%
is often too generic to synthesize useful generators in practical scenarios.
%
For instance, because of the types we use for deriving our generators are too
general, the generation process leaves a large room for ill-formed values, e.g.,
invalid HTML pages; or alternatively, because it fails at generating very
specific patterns of values which might be needed to trigger bugs.
%
% because our properties need to be tested against very specific input patterns in
% order to trigger bugs.


This problem, however, can be alleviated by considering additional sources of
structural information from our codebase other than just type definitions
\cite{Mista2019GeneratingRS}.
%
% For instance, having a set of high-level combinators, defining an abstract
% interface of our data types, e.g., |hr :: Html| or |bold :: Html -> Html|; it is
% possible to include them into the generation process, thus obtaining more
% complex and structured values.
%
For instance, it is possible to include into the generation process a set of
high-level combinators of our data types, e.g., |hr :: Html| or |bold :: Html ->
Html|---thus obtaining more complex and structured values.
%
This methodology of generating random data using high-level combinators has
shown to be particulary useful in the presence of monadic code
\cite{Claessen:2002, grieco2017}.
%
% In the same way, having functions defined using pattern matching over the data
% types of our interest, e.g. |f (Join (Text t) (Tag s x)) = dots|, it is also
% possible to include this rich structure which exposes a relationship among
% different data constructors into our random generators.
%
In the same way, it is possible to include into the generation process the
pattern matchings that different functions perform over the data types of our
interest, e.g. |f (Join (Text t) (Tag s x)) = dots|.
%
Such patterns often expose interesting relationships between multiple data
constructors, a valuable asset for testing complex systems expecting highly
structured inputs \cite{klein2009randomized}.
%
% This idea is addressed in depth in the next section, while the rest of this work
% focuses on implementing it in a compositional way.
%
This work shows how to modularly include these extra sources of structural
information into our automatically derived generators in a compositional manner.

%
% Contributions
%
The main contribution of this paper are:
%
\begin{CompactItemize}
\item We identify some important limitations of performing random testing with
  automatically derived generators using state-of-the-art tools (Section
  \ref{sec:sources}).
\item We present an extensible mechanism for representing random values built
  upon different sources of structural information using Data Types \`a la Carte
  (Section \ref{sec:representation}).
\item We develop a modular generation schema, exploiting the composable nature
  of our representations, which are extended to encode information relevant to
  the generation process at the type level (Section \ref{sec:generators}).
\item We propose a simple type-level idiom for describing extensible generators,
  based on the types used to represent the desired shape of our random data
  (Section \ref{sec:typelevel}).\looseness=-1
\item We provide a Template Haskell tool%
  %
  \footnote{Link will be made available for the final version of this paper.}
  %
  for automatically deriving all the required machinery presented throughout
  this paper, and evaluate its generation performance using three real-world
  case studies (Section \ref{sec:casestudies}).
\end{CompactItemize}
%
Overall, we present a novel technique for reusing automatically derived
generators in a composable fashion, in contrast to the usual paradigm of
automatically deriving ``rigid'', monolithic generators.
